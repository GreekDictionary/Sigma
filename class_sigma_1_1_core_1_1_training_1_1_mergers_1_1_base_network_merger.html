<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sigma: Sigma.Core.Training.Mergers.BaseNetworkMerger Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="128x128.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sigma
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_sigma.html">Sigma</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core.html">Core</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_training.html">Training</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_training_1_1_mergers.html">Mergers</a></li><li class="navelem"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html">BaseNetworkMerger</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sigma.Core.Training.Mergers.BaseNetworkMerger Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html" title="This is the BaseNetworkMerger - it provides functionality that should make it easier to implement the...">BaseNetworkMerger</a> - it provides functionality that should make it easier to implement the <a class="el" href="interface_sigma_1_1_core_1_1_training_1_1_mergers_1_1_i_network_merger.html" title="This interface specifies a way to merge multiple INetworks. When multiple Operators.Workers.IWorker execute their tasks, they push their current network to an Operators.IOperator. These pushed networks have to be merged by an INetworkMerger. ">INetworkMerger</a> interface.  
 <a href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Sigma.Core.Training.Mergers.BaseNetworkMerger:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.png" usemap="#Sigma.Core.Training.Mergers.BaseNetworkMerger_map" alt=""/>
  <map id="Sigma.Core.Training.Mergers.BaseNetworkMerger_map" name="Sigma.Core.Training.Mergers.BaseNetworkMerger_map">
<area href="interface_sigma_1_1_core_1_1_training_1_1_mergers_1_1_i_network_merger.html" title="This interface specifies a way to merge multiple INetworks. When multiple Operators.Workers.IWorker execute their tasks, they push their current network to an Operators.IOperator. These pushed networks have to be merged by an INetworkMerger. " alt="Sigma.Core.Training.Mergers.INetworkMerger" shape="rect" coords="167,0,491,24"/>
<area href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_average_network_merger.html" title="A INetworkMerger that simple adds all values together and divides it by the amount (arithmetic mean)..." alt="Sigma.Core.Training.Mergers.AverageNetworkMerger" shape="rect" coords="0,112,324,136"/>
<area href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_weighted_network_merger.html" title="A INetworkMerger that specifies how important each network is. One can specify that the second networ..." alt="Sigma.Core.Training.Mergers.WeightedNetworkMerger" shape="rect" coords="334,112,658,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38bf1c7a3e90e3514cc63db7242902cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a38bf1c7a3e90e3514cc63db7242902cb">Merge</a> (<a class="el" href="interface_sigma_1_1_core_1_1_architecture_1_1_i_network.html">INetwork</a> root, IEnumerable&lt; <a class="el" href="interface_sigma_1_1_core_1_1_architecture_1_1_i_network.html">INetwork</a> &gt; networks, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler=null)</td></tr>
<tr class="memdesc:a38bf1c7a3e90e3514cc63db7242902cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify how multiple networks are merged into a single one. root is <em>not</em> considered for the calculation. It is merely the storage container. (Although root can also be in networks).  <a href="#a38bf1c7a3e90e3514cc63db7242902cb">More...</a><br /></td></tr>
<tr class="separator:a38bf1c7a3e90e3514cc63db7242902cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86641eddac5a43945e439e978abb1c10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a86641eddac5a43945e439e978abb1c10">Merge</a> (<a class="el" href="interface_sigma_1_1_core_1_1_architecture_1_1_i_network.html">INetwork</a> root, <a class="el" href="interface_sigma_1_1_core_1_1_architecture_1_1_i_network.html">INetwork</a> other, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler=null)</td></tr>
<tr class="memdesc:a86641eddac5a43945e439e978abb1c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify how two networks are merged into a single one (root = root + other). This method can be achieved with <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a38bf1c7a3e90e3514cc63db7242902cb" title="Specify how multiple networks are merged into a single one. root is not considered for the calculatio...">Merge(INetwork,IEnumerable&lt;INetwork&gt;,IComputationHandler)</a> (internally implemented this way), but it may be easier to call this function.  <a href="#a86641eddac5a43945e439e978abb1c10">More...</a><br /></td></tr>
<tr class="separator:a86641eddac5a43945e439e978abb1c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3849c9891ae639ffe4592804e531c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a5f3849c9891ae639ffe4592804e531c0">AddMergeEntry</a> (string matchIdentifier)</td></tr>
<tr class="memdesc:a5f3849c9891ae639ffe4592804e531c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the registry keys (match identifiers) that will be merged. This supports the full <a class="el" href="interface_sigma_1_1_core_1_1_utils_1_1_i_registry_resolver.html" title="A registry resolver that resolves layered identifiers. Implementations are expected but not required ...">Utils.IRegistryResolver</a> syntax.  <a href="#a5f3849c9891ae639ffe4592804e531c0">More...</a><br /></td></tr>
<tr class="separator:a5f3849c9891ae639ffe4592804e531c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0bd79506c20aa5603156347b11fc29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a2f0bd79506c20aa5603156347b11fc29">RemoveMergeEntry</a> (string matchIdentifier)</td></tr>
<tr class="memdesc:a2f0bd79506c20aa5603156347b11fc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously specified match identifier.  <a href="#a2f0bd79506c20aa5603156347b11fc29">More...</a><br /></td></tr>
<tr class="separator:a2f0bd79506c20aa5603156347b11fc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acc1bbede7346bf01ace90c79829d8d7e"><td class="memItemLeft" align="right" valign="top"><a id="acc1bbede7346bf01ace90c79829d8d7e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BaseNetworkMerger</b> (params string[] matchIdentifiers)</td></tr>
<tr class="separator:acc1bbede7346bf01ace90c79829d8d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464d018fd8f1367dae8084f203624e7d"><td class="memItemLeft" align="right" valign="top">virtual object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a464d018fd8f1367dae8084f203624e7d">MergeDefault</a> (object[] objects, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:a464d018fd8f1367dae8084f203624e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method that will be called when no other method suits.  <a href="#a464d018fd8f1367dae8084f203624e7d">More...</a><br /></td></tr>
<tr class="separator:a464d018fd8f1367dae8084f203624e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435c604b17887ae2da4c3313883dd060"><td class="memItemLeft" align="right" valign="top">abstract double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a435c604b17887ae2da4c3313883dd060">MergeDoubles</a> (double[] doubles)</td></tr>
<tr class="memdesc:a435c604b17887ae2da4c3313883dd060"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to merge doubles.  <a href="#a435c604b17887ae2da4c3313883dd060">More...</a><br /></td></tr>
<tr class="separator:a435c604b17887ae2da4c3313883dd060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406767bb9c6c84fb9e44f1797dcd9d52"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a406767bb9c6c84fb9e44f1797dcd9d52">MergeFloats</a> (float[] floats)</td></tr>
<tr class="memdesc:a406767bb9c6c84fb9e44f1797dcd9d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to merge floats. Override it as you need, but per default it calls <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a435c604b17887ae2da4c3313883dd060" title="This method is used to merge doubles. ">MergeDoubles</a>.  <a href="#a406767bb9c6c84fb9e44f1797dcd9d52">More...</a><br /></td></tr>
<tr class="separator:a406767bb9c6c84fb9e44f1797dcd9d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae190363d7942c335db38ecf9ae7696"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#aeae190363d7942c335db38ecf9ae7696">MergeInts</a> (int[] ints)</td></tr>
<tr class="memdesc:aeae190363d7942c335db38ecf9ae7696"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to merge floats. Override it as you need, but per default it calls <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a435c604b17887ae2da4c3313883dd060" title="This method is used to merge doubles. ">MergeDoubles</a>.  <a href="#aeae190363d7942c335db38ecf9ae7696">More...</a><br /></td></tr>
<tr class="separator:aeae190363d7942c335db38ecf9ae7696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c53a0a3cb201d5719fc05229b5699d6"><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a9c53a0a3cb201d5719fc05229b5699d6">MergeShorts</a> (short[] shorts)</td></tr>
<tr class="memdesc:a9c53a0a3cb201d5719fc05229b5699d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to merge floats. Override it as you need, but per default it calls <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a435c604b17887ae2da4c3313883dd060" title="This method is used to merge doubles. ">MergeDoubles</a>.  <a href="#a9c53a0a3cb201d5719fc05229b5699d6">More...</a><br /></td></tr>
<tr class="separator:a9c53a0a3cb201d5719fc05229b5699d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54d689dbc7165e5b467a081dd6934db"><td class="memItemLeft" align="right" valign="top">virtual long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#ab54d689dbc7165e5b467a081dd6934db">MergeLongs</a> (long[] longs)</td></tr>
<tr class="memdesc:ab54d689dbc7165e5b467a081dd6934db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to merge floats. Override it as you need, but per default it calls <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a435c604b17887ae2da4c3313883dd060" title="This method is used to merge doubles. ">MergeDoubles</a>.  <a href="#ab54d689dbc7165e5b467a081dd6934db">More...</a><br /></td></tr>
<tr class="separator:ab54d689dbc7165e5b467a081dd6934db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3b27b637a6816d290ebc7f9d231044"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#aef3b27b637a6816d290ebc7f9d231044">MergeNDArrays</a> (<a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>[] arrays, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:aef3b27b637a6816d290ebc7f9d231044"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to merge INDArrays.  <a href="#aef3b27b637a6816d290ebc7f9d231044">More...</a><br /></td></tr>
<tr class="separator:aef3b27b637a6816d290ebc7f9d231044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7ce738802372e903380bd3257ed5f2"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_number.html">INumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#aee7ce738802372e903380bd3257ed5f2">MergeNumbers</a> (<a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_number.html">INumber</a>[] numbers, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:aee7ce738802372e903380bd3257ed5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to merge INDArrays.  <a href="#aee7ce738802372e903380bd3257ed5f2">More...</a><br /></td></tr>
<tr class="separator:aee7ce738802372e903380bd3257ed5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe9a647bb719a6d42e48c1f8ac1c319"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#aabe9a647bb719a6d42e48c1f8ac1c319">CheckObjects</a> (object[] objects)</td></tr>
<tr class="memdesc:aabe9a647bb719a6d42e48c1f8ac1c319"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets called before merge is called. So if your class has attributes that have to be checked before every merge, feel free to override this method. Per default it is an empty method. (i.e. no back calling required)  <a href="#aabe9a647bb719a6d42e48c1f8ac1c319">More...</a><br /></td></tr>
<tr class="separator:aabe9a647bb719a6d42e48c1f8ac1c319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41807c940bfc7ca6b3e7de448ea7a2c0"><td class="memItemLeft" align="right" valign="top">virtual object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a41807c940bfc7ca6b3e7de448ea7a2c0">Merge</a> (object[] objects, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:a41807c940bfc7ca6b3e7de448ea7a2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks every object in objects if it can be casted to a type, and if everything can be casted, calls the correct method. As last resort, <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a464d018fd8f1367dae8084f203624e7d" title="The method that will be called when no other method suits. ">MergeDefault</a> will be called.  <a href="#a41807c940bfc7ca6b3e7de448ea7a2c0">More...</a><br /></td></tr>
<tr class="separator:a41807c940bfc7ca6b3e7de448ea7a2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0e4f2d067519a40568641120eaed60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#aef0e4f2d067519a40568641120eaed60">CastToAndCall&lt; T &gt;</a> (object[] objects, Func&lt; T[], T &gt; calculate, out object mergedObject)</td></tr>
<tr class="memdesc:aef0e4f2d067519a40568641120eaed60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method tries to cast every object of objects to T. If all objects can be casted, it calls the passed calculate function.  <a href="#aef0e4f2d067519a40568641120eaed60">More...</a><br /></td></tr>
<tr class="separator:aef0e4f2d067519a40568641120eaed60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a41e0d91f553eb1aaf38939d114c3b7db"><td class="memItemLeft" align="right" valign="top">readonly ICollection&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a41e0d91f553eb1aaf38939d114c3b7db">MatchIdentifier</a></td></tr>
<tr class="memdesc:a41e0d91f553eb1aaf38939d114c3b7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matching keys.  <a href="#a41e0d91f553eb1aaf38939d114c3b7db">More...</a><br /></td></tr>
<tr class="separator:a41e0d91f553eb1aaf38939d114c3b7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b348991c5f8e298b14f2725db16e2f7"><td class="memItemLeft" align="right" valign="top"><a id="a0b348991c5f8e298b14f2725db16e2f7"></a>
ILog&#160;</td><td class="memItemRight" valign="bottom"><b>Log</b> =&gt; _log ?? (_log = LogManager.GetLogger(GetType()))</td></tr>
<tr class="separator:a0b348991c5f8e298b14f2725db16e2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a633a90c081e578cb249149a1f90ca6cb"><td class="memItemLeft" align="right" valign="top">object []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a633a90c081e578cb249149a1f90ca6cb">GetAllObjectsWithIndex</a> (IList&lt; object[]&gt; list, int index)</td></tr>
<tr class="memdesc:a633a90c081e578cb249149a1f90ca6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns from a list, from every object[], the ith index. e.g. 3 passed objects[] =&gt; get index 2, returns an object[] with a length of 3 and from everyone the second index.  <a href="#a633a90c081e578cb249149a1f90ca6cb">More...</a><br /></td></tr>
<tr class="separator:a633a90c081e578cb249149a1f90ca6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa89a575fc91aef300ad349c1fde82d"><td class="memItemLeft" align="right" valign="top">string []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a4aa89a575fc91aef300ad349c1fde82d">CopyMatchIdentifiers</a> ()</td></tr>
<tr class="memdesc:a4aa89a575fc91aef300ad349c1fde82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a41e0d91f553eb1aaf38939d114c3b7db" title="The matching keys. ">MatchIdentifier</a>s into a string[], so it can be used without a lock.  <a href="#a4aa89a575fc91aef300ad349c1fde82d">More...</a><br /></td></tr>
<tr class="separator:a4aa89a575fc91aef300ad349c1fde82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a81f7ca7f5b29834185f263b3c5c0370f"><td class="memItemLeft" align="right" valign="top"><a id="a81f7ca7f5b29834185f263b3c5c0370f"></a>
ILog&#160;</td><td class="memItemRight" valign="bottom"><b>_log</b></td></tr>
<tr class="separator:a81f7ca7f5b29834185f263b3c5c0370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html" title="This is the BaseNetworkMerger - it provides functionality that should make it easier to implement the...">BaseNetworkMerger</a> - it provides functionality that should make it easier to implement the <a class="el" href="interface_sigma_1_1_core_1_1_training_1_1_mergers_1_1_i_network_merger.html" title="This interface specifies a way to merge multiple INetworks. When multiple Operators.Workers.IWorker execute their tasks, they push their current network to an Operators.IOperator. These pushed networks have to be merged by an INetworkMerger. ">INetworkMerger</a> interface. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5f3849c9891ae639ffe4592804e531c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3849c9891ae639ffe4592804e531c0">&#9670;&nbsp;</a></span>AddMergeEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sigma.Core.Training.Mergers.BaseNetworkMerger.AddMergeEntry </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>matchIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the registry keys (match identifiers) that will be merged. This supports the full <a class="el" href="interface_sigma_1_1_core_1_1_utils_1_1_i_registry_resolver.html" title="A registry resolver that resolves layered identifiers. Implementations are expected but not required ...">Utils.IRegistryResolver</a> syntax. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matchIdentifier</td><td>The key of the registry.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_training_1_1_mergers_1_1_i_network_merger.html#a80804f554c0654c801a7b16a21bc4110">Sigma.Core.Training.Mergers.INetworkMerger</a>.</p>

</div>
</div>
<a id="aef0e4f2d067519a40568641120eaed60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0e4f2d067519a40568641120eaed60">&#9670;&nbsp;</a></span>CastToAndCall< T >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Training.Mergers.BaseNetworkMerger.CastToAndCall&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">object []&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T[], T &gt;&#160;</td>
          <td class="paramname"><em>calculate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out object&#160;</td>
          <td class="paramname"><em>mergedObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method tries to cast every object of objects to T. If all objects can be casted, it calls the passed calculate function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The object to cast to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objects</td><td>The objects that will be passed.</td></tr>
    <tr><td class="paramname">calculate</td><td>The method that will be called if all objects can be converted.</td></tr>
    <tr><td class="paramname">mergedObject</td><td>The merged object (initialised with a simple call of calculate).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If any of those objects cannot be casted (and therefore the creation of an T[] is impossible), <code>false</code>. <code>True</code> otherwise. </dd></dl>

</div>
</div>
<a id="aabe9a647bb719a6d42e48c1f8ac1c319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe9a647bb719a6d42e48c1f8ac1c319">&#9670;&nbsp;</a></span>CheckObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Sigma.Core.Training.Mergers.BaseNetworkMerger.CheckObjects </td>
          <td>(</td>
          <td class="paramtype">object []&#160;</td>
          <td class="paramname"><em>objects</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method gets called before merge is called. So if your class has attributes that have to be checked before every merge, feel free to override this method. Per default it is an empty method. (i.e. no back calling required) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objects</td><td>The objects that will be merged.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_weighted_network_merger.html#a514596ec9a23d6e70031d0237197bdbe">Sigma.Core.Training.Mergers.WeightedNetworkMerger</a>.</p>

</div>
</div>
<a id="a4aa89a575fc91aef300ad349c1fde82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa89a575fc91aef300ad349c1fde82d">&#9670;&nbsp;</a></span>CopyMatchIdentifiers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string [] Sigma.Core.Training.Mergers.BaseNetworkMerger.CopyMatchIdentifiers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a41e0d91f553eb1aaf38939d114c3b7db" title="The matching keys. ">MatchIdentifier</a>s into a string[], so it can be used without a lock. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of all elements currently in <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a4aa89a575fc91aef300ad349c1fde82d" title="Copy the MatchIdentifiers into a string[], so it can be used without a lock. ">CopyMatchIdentifiers</a>.</dd></dl>

</div>
</div>
<a id="a633a90c081e578cb249149a1f90ca6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633a90c081e578cb249149a1f90ca6cb">&#9670;&nbsp;</a></span>GetAllObjectsWithIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">object [] Sigma.Core.Training.Mergers.BaseNetworkMerger.GetAllObjectsWithIndex </td>
          <td>(</td>
          <td class="paramtype">IList&lt; object[]&gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns from a list, from every object[], the ith index. e.g. 3 passed objects[] =&gt; get index 2, returns an object[] with a length of 3 and from everyone the second index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list the action will be performed on. (Normally amount of networks).</td></tr>
    <tr><td class="paramname">index</td><td>The index we are looking for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object[] specified previously how it is generated.</dd></dl>

</div>
</div>
<a id="a38bf1c7a3e90e3514cc63db7242902cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bf1c7a3e90e3514cc63db7242902cb">&#9670;&nbsp;</a></span>Merge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sigma.Core.Training.Mergers.BaseNetworkMerger.Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_architecture_1_1_i_network.html">INetwork</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="interface_sigma_1_1_core_1_1_architecture_1_1_i_network.html">INetwork</a> &gt;&#160;</td>
          <td class="paramname"><em>networks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify how multiple networks are merged into a single one. root is <em>not</em> considered for the calculation. It is merely the storage container. (Although root can also be in networks). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The root network that will be modified. Since the <a class="el" href="interface_sigma_1_1_core_1_1_training_1_1_mergers_1_1_i_network_merger.html" title="This interface specifies a way to merge multiple INetworks. When multiple Operators.Workers.IWorker execute their tasks, they push their current network to an Operators.IOperator. These pushed networks have to be merged by an INetworkMerger. ">INetworkMerger</a> does not know how to create a INetwork, it will be passed not returned. </td></tr>
    <tr><td class="paramname">networks</td><td>The networks that will be merged into the root. Can contain root itself. </td></tr>
    <tr><td class="paramname">handler</td><td>A handler can be specified optionally. If not passed (but required), <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html#ae84f817a09e9205af9fa0e11f5d973b5" title="The computation handler associated with this traceable object (null if none). ">MathAbstract.ITraceable.AssociatedHandler</a> will be used. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_training_1_1_mergers_1_1_i_network_merger.html#a54482985eec1de5c12953e9059ff12d8">Sigma.Core.Training.Mergers.INetworkMerger</a>.</p>

</div>
</div>
<a id="a86641eddac5a43945e439e978abb1c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86641eddac5a43945e439e978abb1c10">&#9670;&nbsp;</a></span>Merge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sigma.Core.Training.Mergers.BaseNetworkMerger.Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_architecture_1_1_i_network.html">INetwork</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_architecture_1_1_i_network.html">INetwork</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify how two networks are merged into a single one (root = root + other). This method can be achieved with <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a38bf1c7a3e90e3514cc63db7242902cb" title="Specify how multiple networks are merged into a single one. root is not considered for the calculatio...">Merge(INetwork,IEnumerable&lt;INetwork&gt;,IComputationHandler)</a> (internally implemented this way), but it may be easier to call this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The root network that will be modified and contain the result.</td></tr>
    <tr><td class="paramname">other</td><td>The unchanged other network.</td></tr>
    <tr><td class="paramname">handler</td><td>A handler can be specified optionally. If not passed (but required), <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html#ae84f817a09e9205af9fa0e11f5d973b5" title="The computation handler associated with this traceable object (null if none). ">MathAbstract.ITraceable.AssociatedHandler</a> will be used. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_training_1_1_mergers_1_1_i_network_merger.html#a95534a813d4b1fae4a7aeb34afcc7049">Sigma.Core.Training.Mergers.INetworkMerger</a>.</p>

</div>
</div>
<a id="a41807c940bfc7ca6b3e7de448ea7a2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41807c940bfc7ca6b3e7de448ea7a2c0">&#9670;&nbsp;</a></span>Merge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual object Sigma.Core.Training.Mergers.BaseNetworkMerger.Merge </td>
          <td>(</td>
          <td class="paramtype">object []&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks every object in objects if it can be casted to a type, and if everything can be casted, calls the correct method. As last resort, <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a464d018fd8f1367dae8084f203624e7d" title="The method that will be called when no other method suits. ">MergeDefault</a> will be called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objects</td><td>The objects that will be merged.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler that may or may not be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A merged object.</dd></dl>

</div>
</div>
<a id="a464d018fd8f1367dae8084f203624e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464d018fd8f1367dae8084f203624e7d">&#9670;&nbsp;</a></span>MergeDefault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual object Sigma.Core.Training.Mergers.BaseNetworkMerger.MergeDefault </td>
          <td>(</td>
          <td class="paramtype">object []&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method that will be called when no other method suits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objects</td><td>The objects.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler (may be null). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Reimplemented in <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_weighted_network_merger.html#a2a64388676a62f1d39d1460a2150515c">Sigma.Core.Training.Mergers.WeightedNetworkMerger</a>, and <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_average_network_merger.html#aaec5ac0451be1495cc2ccdfc8ae43ca1">Sigma.Core.Training.Mergers.AverageNetworkMerger</a>.</p>

</div>
</div>
<a id="a435c604b17887ae2da4c3313883dd060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435c604b17887ae2da4c3313883dd060">&#9670;&nbsp;</a></span>MergeDoubles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract double Sigma.Core.Training.Mergers.BaseNetworkMerger.MergeDoubles </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>doubles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to merge doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doubles</td><td>The doubles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The merged value.</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_weighted_network_merger.html#a0839b7b2126e068efae553ebbe0dac6a">Sigma.Core.Training.Mergers.WeightedNetworkMerger</a>, and <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_average_network_merger.html#ab53c82a5d2bebf40489caa84a1d1fe64">Sigma.Core.Training.Mergers.AverageNetworkMerger</a>.</p>

</div>
</div>
<a id="a406767bb9c6c84fb9e44f1797dcd9d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406767bb9c6c84fb9e44f1797dcd9d52">&#9670;&nbsp;</a></span>MergeFloats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Sigma.Core.Training.Mergers.BaseNetworkMerger.MergeFloats </td>
          <td>(</td>
          <td class="paramtype">float []&#160;</td>
          <td class="paramname"><em>floats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to merge floats. Override it as you need, but per default it calls <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a435c604b17887ae2da4c3313883dd060" title="This method is used to merge doubles. ">MergeDoubles</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">floats</td><td>The floats.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The merged value.</dd></dl>

</div>
</div>
<a id="aeae190363d7942c335db38ecf9ae7696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae190363d7942c335db38ecf9ae7696">&#9670;&nbsp;</a></span>MergeInts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Sigma.Core.Training.Mergers.BaseNetworkMerger.MergeInts </td>
          <td>(</td>
          <td class="paramtype">int []&#160;</td>
          <td class="paramname"><em>ints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to merge floats. Override it as you need, but per default it calls <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a435c604b17887ae2da4c3313883dd060" title="This method is used to merge doubles. ">MergeDoubles</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ints</td><td>The ints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The merged value.</dd></dl>

</div>
</div>
<a id="ab54d689dbc7165e5b467a081dd6934db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54d689dbc7165e5b467a081dd6934db">&#9670;&nbsp;</a></span>MergeLongs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long Sigma.Core.Training.Mergers.BaseNetworkMerger.MergeLongs </td>
          <td>(</td>
          <td class="paramtype">long []&#160;</td>
          <td class="paramname"><em>longs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to merge floats. Override it as you need, but per default it calls <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a435c604b17887ae2da4c3313883dd060" title="This method is used to merge doubles. ">MergeDoubles</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">longs</td><td>The longs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The merged value.</dd></dl>

</div>
</div>
<a id="aef3b27b637a6816d290ebc7f9d231044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3b27b637a6816d290ebc7f9d231044">&#9670;&nbsp;</a></span>MergeNDArrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.Training.Mergers.BaseNetworkMerger.MergeNDArrays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> []&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to merge INDArrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrays</td><td>The arrays to merge. </td></tr>
    <tr><td class="paramname">handler</td><td>The handler that may or may not be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A merged INDArray.</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_weighted_network_merger.html#a1338671759a5257ccd4dd2e865ba4928">Sigma.Core.Training.Mergers.WeightedNetworkMerger</a>, and <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_average_network_merger.html#aac12393972af08f3b2f5ec1d780b86c9">Sigma.Core.Training.Mergers.AverageNetworkMerger</a>.</p>

</div>
</div>
<a id="aee7ce738802372e903380bd3257ed5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7ce738802372e903380bd3257ed5f2">&#9670;&nbsp;</a></span>MergeNumbers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_number.html">INumber</a> Sigma.Core.Training.Mergers.BaseNetworkMerger.MergeNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_number.html">INumber</a> []&#160;</td>
          <td class="paramname"><em>numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to merge INDArrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbers</td><td>The numbers to merge. </td></tr>
    <tr><td class="paramname">handler</td><td>The handler that may or may not be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A merged INumber.</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_weighted_network_merger.html#a927eac91bfb77e434121212700913df1">Sigma.Core.Training.Mergers.WeightedNetworkMerger</a>, and <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_average_network_merger.html#ac5ba043565dd39e93eb48649879d9023">Sigma.Core.Training.Mergers.AverageNetworkMerger</a>.</p>

</div>
</div>
<a id="a9c53a0a3cb201d5719fc05229b5699d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c53a0a3cb201d5719fc05229b5699d6">&#9670;&nbsp;</a></span>MergeShorts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual short Sigma.Core.Training.Mergers.BaseNetworkMerger.MergeShorts </td>
          <td>(</td>
          <td class="paramtype">short []&#160;</td>
          <td class="paramname"><em>shorts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to merge floats. Override it as you need, but per default it calls <a class="el" href="class_sigma_1_1_core_1_1_training_1_1_mergers_1_1_base_network_merger.html#a435c604b17887ae2da4c3313883dd060" title="This method is used to merge doubles. ">MergeDoubles</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shorts</td><td>The shorts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The merged value.</dd></dl>

</div>
</div>
<a id="a2f0bd79506c20aa5603156347b11fc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0bd79506c20aa5603156347b11fc29">&#9670;&nbsp;</a></span>RemoveMergeEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sigma.Core.Training.Mergers.BaseNetworkMerger.RemoveMergeEntry </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>matchIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a previously specified match identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matchIdentifier</td><td>The key to remove from the targeted registries.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_training_1_1_mergers_1_1_i_network_merger.html#ac793ca18de1b1b640625b5a23e4ef573">Sigma.Core.Training.Mergers.INetworkMerger</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a41e0d91f553eb1aaf38939d114c3b7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e0d91f553eb1aaf38939d114c3b7db">&#9670;&nbsp;</a></span>MatchIdentifier</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly ICollection&lt;string&gt; Sigma.Core.Training.Mergers.BaseNetworkMerger.MatchIdentifier</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The matching keys. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Plainer/Documents/GitHub/Sigma/Sigma.Core/Training/Mergers/BaseNetworkMerger.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
