<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sigma: Sigma.Core.MathAbstract.INDArray Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="128x128.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sigma
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_sigma.html">Sigma</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core.html">Core</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_math_abstract.html">MathAbstract</a></li><li class="navelem"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sigma.Core.MathAbstract.INDArray Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An n-dimensional array of any data type with C-like ordering. Includes utility functions for scalar, vector and matrix manipulation.  
 <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Sigma.Core.MathAbstract.INDArray:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.png" usemap="#Sigma.Core.MathAbstract.INDArray_map" alt=""/>
  <map id="Sigma.Core.MathAbstract.INDArray_map" name="Sigma.Core.MathAbstract.INDArray_map">
<area href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html" title="A traceable mathematical object. " alt="Sigma.Core.MathAbstract.ITraceable" shape="rect" coords="0,0,378,24"/>
<area href="interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable.html" title="A deep copyable object. &quot;Deep&quot; means all child references are recursively copied down to actual copya..." alt="Sigma.Core.Utils.IDeepCopyable" shape="rect" coords="388,0,766,24"/>
<area href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html" title="A default, in-system-memory implementation of the INDArray interface. " alt="Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;" shape="rect" coords="194,112,572,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a11f923a488660b89ad4cbf910a39f42c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_i_data_buffer.html">IDataBuffer</a>&lt; TOther &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a11f923a488660b89ad4cbf910a39f42c">GetDataAs&lt; TOther &gt;</a> ()</td></tr>
<tr class="memdesc:a11f923a488660b89ad4cbf910a39f42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a COPY of the underlying data buffer as a certain data type.  <a href="#a11f923a488660b89ad4cbf910a39f42c">More...</a><br /></td></tr>
<tr class="separator:a11f923a488660b89ad4cbf910a39f42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aed17ce39ec790b3bad7e146f042903"><td class="memItemLeft" align="right" valign="top">TOther&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a9aed17ce39ec790b3bad7e146f042903">GetValue&lt; TOther &gt;</a> (params long[] indices)</td></tr>
<tr class="memdesc:a9aed17ce39ec790b3bad7e146f042903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a value at a certain index as a certain type. Note: The value might have to be internally explicitly cast to the requested type (and thereby change).  <a href="#a9aed17ce39ec790b3bad7e146f042903">More...</a><br /></td></tr>
<tr class="separator:a9aed17ce39ec790b3bad7e146f042903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff221e48e75e5de20c6cae58a59cf0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a7ff221e48e75e5de20c6cae58a59cf0f">SetValue&lt; TOther &gt;</a> (TOther value, params long[] indices)</td></tr>
<tr class="memdesc:a7ff221e48e75e5de20c6cae58a59cf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a value of a certain type at a certain index. Note: The value might have to be internally explicitly cast to the internally used type (and thereby change).  <a href="#a7ff221e48e75e5de20c6cae58a59cf0f">More...</a><br /></td></tr>
<tr class="separator:a7ff221e48e75e5de20c6cae58a59cf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d893a6ca95de9a04cbd2972391af3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a89d893a6ca95de9a04cbd2972391af3a">Slice</a> (long[] beginIndices, long[] endIndices)</td></tr>
<tr class="memdesc:a89d893a6ca95de9a04cbd2972391af3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a slice of this ndarray of a certain region as a new ndarray with the same underlying data.  <a href="#a89d893a6ca95de9a04cbd2972391af3a">More...</a><br /></td></tr>
<tr class="separator:a89d893a6ca95de9a04cbd2972391af3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811f9ab94bae55a882fef7f2f2462fca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a811f9ab94bae55a882fef7f2f2462fca">Reshape</a> (params long[] newShape)</td></tr>
<tr class="memdesc:a811f9ab94bae55a882fef7f2f2462fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a NEW ndarray with the same data but another shape (and different strides). Note: The total length of the ndarray cannot change.  <a href="#a811f9ab94bae55a882fef7f2f2462fca">More...</a><br /></td></tr>
<tr class="separator:a811f9ab94bae55a882fef7f2f2462fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d8cdce99b5d58221dbb71bd06c5ae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#aa0d8cdce99b5d58221dbb71bd06c5ae0">ReshapeSelf</a> (params long[] newShape)</td></tr>
<tr class="memdesc:aa0d8cdce99b5d58221dbb71bd06c5ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape THIS ndarray to a new shape (this operation also changes strides). Note: The total length of the ndarray cannot change.  <a href="#aa0d8cdce99b5d58221dbb71bd06c5ae0">More...</a><br /></td></tr>
<tr class="separator:aa0d8cdce99b5d58221dbb71bd06c5ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd26fddf232c4c1d3d6459f14fafcddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#acd26fddf232c4c1d3d6459f14fafcddb">Permute</a> (params int[] rearrangedDimensions)</td></tr>
<tr class="memdesc:acd26fddf232c4c1d3d6459f14fafcddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a NEW ndarray with the same data but another permuted shape (and also different strides). Permutation occurs according to the content of the rearranged dimensions array, where each element represents the number of a dimension to swap with. The permutation array has to have the same number of dimensions as the actual shape.  <a href="#acd26fddf232c4c1d3d6459f14fafcddb">More...</a><br /></td></tr>
<tr class="separator:acd26fddf232c4c1d3d6459f14fafcddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d870bf4c4a940eaebb6b1edf8c60558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a1d870bf4c4a940eaebb6b1edf8c60558">PermuteSelf</a> (params int[] rearrangedDimensions)</td></tr>
<tr class="memdesc:a1d870bf4c4a940eaebb6b1edf8c60558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute THIS ndarray to another permuted shape (and also different strides). Permutation occurs according to the content of the rearranged dimensions array, where each element represents the number of a dimension to swap with. The permutation array has to have the same number of dimensions as the actual shape.  <a href="#a1d870bf4c4a940eaebb6b1edf8c60558">More...</a><br /></td></tr>
<tr class="separator:a1d870bf4c4a940eaebb6b1edf8c60558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bd3d64fde5e14da25c90cac2e0a588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a34bd3d64fde5e14da25c90cac2e0a588">Transpose</a> ()</td></tr>
<tr class="memdesc:a34bd3d64fde5e14da25c90cac2e0a588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a NEW ndarray with the same data but transposed (reversed dimensions).  <a href="#a34bd3d64fde5e14da25c90cac2e0a588">More...</a><br /></td></tr>
<tr class="separator:a34bd3d64fde5e14da25c90cac2e0a588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a91147f2ab41c01e4c33d0d9213d7b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a7a91147f2ab41c01e4c33d0d9213d7b9">TransposeSelf</a> ()</td></tr>
<tr class="memdesc:a7a91147f2ab41c01e4c33d0d9213d7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose THIS ndarray (reverse dimensions).  <a href="#a7a91147f2ab41c01e4c33d0d9213d7b9">More...</a><br /></td></tr>
<tr class="separator:a7a91147f2ab41c01e4c33d0d9213d7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74af7dbdbf9453beedefa2d6d5fd6375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a74af7dbdbf9453beedefa2d6d5fd6375">Flatten</a> ()</td></tr>
<tr class="memdesc:a74af7dbdbf9453beedefa2d6d5fd6375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a NEW flattened ndarray with the same data but a flat shape (row vector).  <a href="#a74af7dbdbf9453beedefa2d6d5fd6375">More...</a><br /></td></tr>
<tr class="separator:a74af7dbdbf9453beedefa2d6d5fd6375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4426b31633f4d8b46cfe8af864a8e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a6b4426b31633f4d8b46cfe8af864a8e6">FlattenSelf</a> ()</td></tr>
<tr class="memdesc:a6b4426b31633f4d8b46cfe8af864a8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten THIS ndarray to a flat row vector.  <a href="#a6b4426b31633f4d8b46cfe8af864a8e6">More...</a><br /></td></tr>
<tr class="separator:a6b4426b31633f4d8b46cfe8af864a8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable.html">Sigma.Core.Utils.IDeepCopyable</a></td></tr>
<tr class="memitem:ab066dde4b00126e9c9b39764887b22b1 inherit pub_methods_interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable"><td class="memItemLeft" align="right" valign="top">object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable.html#ab066dde4b00126e9c9b39764887b22b1">DeepCopy</a> ()</td></tr>
<tr class="memdesc:ab066dde4b00126e9c9b39764887b22b1 inherit pub_methods_interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy this object.  <a href="interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable.html#ab066dde4b00126e9c9b39764887b22b1">More...</a><br /></td></tr>
<tr class="separator:ab066dde4b00126e9c9b39764887b22b1 inherit pub_methods_interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ac2f79ed481caeac8e89285c8628521af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#ac2f79ed481caeac8e89285c8628521af">Rank</a><code> [get]</code></td></tr>
<tr class="memdesc:ac2f79ed481caeac8e89285c8628521af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank of this ndarray (number of dimensions).  <a href="#ac2f79ed481caeac8e89285c8628521af">More...</a><br /></td></tr>
<tr class="separator:ac2f79ed481caeac8e89285c8628521af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b156ef66492a0054a48dd7609f8a4f7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a2b156ef66492a0054a48dd7609f8a4f7">Length</a><code> [get]</code></td></tr>
<tr class="memdesc:a2b156ef66492a0054a48dd7609f8a4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of this ndarray (total number of elements).  <a href="#a2b156ef66492a0054a48dd7609f8a4f7">More...</a><br /></td></tr>
<tr class="separator:a2b156ef66492a0054a48dd7609f8a4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af509c6a88045887f085da4a4a73f2c60"><td class="memItemLeft" align="right" valign="top">long []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#af509c6a88045887f085da4a4a73f2c60">Shape</a><code> [get]</code></td></tr>
<tr class="memdesc:af509c6a88045887f085da4a4a73f2c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shape of this ndarray (i.e. the dimensions).  <a href="#af509c6a88045887f085da4a4a73f2c60">More...</a><br /></td></tr>
<tr class="separator:af509c6a88045887f085da4a4a73f2c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13cd0073779c6083843e1d69b031605"><td class="memItemLeft" align="right" valign="top">long []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#ab13cd0073779c6083843e1d69b031605">Strides</a><code> [get]</code></td></tr>
<tr class="memdesc:ab13cd0073779c6083843e1d69b031605"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strides of this ndarray. A stride at any dimension defines how many elements to skip to move to the next element along that dimension.  <a href="#ab13cd0073779c6083843e1d69b031605">More...</a><br /></td></tr>
<tr class="separator:ab13cd0073779c6083843e1d69b031605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcae99a669db63943952a3b510746df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a2dcae99a669db63943952a3b510746df">IsScalar</a><code> [get]</code></td></tr>
<tr class="memdesc:a2dcae99a669db63943952a3b510746df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience flag indicating if this ndarray is a scalar (i.e. if its shape is {1})  <a href="#a2dcae99a669db63943952a3b510746df">More...</a><br /></td></tr>
<tr class="separator:a2dcae99a669db63943952a3b510746df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42319c4b5ed047c8de183405d7c7f7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#aa42319c4b5ed047c8de183405d7c7f7c">IsVector</a><code> [get]</code></td></tr>
<tr class="memdesc:aa42319c4b5ed047c8de183405d7c7f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience flag indicating if this ndarray is a vector (i.e. if its shape is 1-dimensional)  <a href="#aa42319c4b5ed047c8de183405d7c7f7c">More...</a><br /></td></tr>
<tr class="separator:aa42319c4b5ed047c8de183405d7c7f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92feaa5c25202385ef35b6c671aed207"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a92feaa5c25202385ef35b6c671aed207">IsMatrix</a><code> [get]</code></td></tr>
<tr class="memdesc:a92feaa5c25202385ef35b6c671aed207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience flag indicating if this ndarray is a matrix (i.e. if its shape is 2-dimensional)  <a href="#a92feaa5c25202385ef35b6c671aed207">More...</a><br /></td></tr>
<tr class="separator:a92feaa5c25202385ef35b6c671aed207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html">Sigma.Core.MathAbstract.ITraceable</a></td></tr>
<tr class="memitem:ae84f817a09e9205af9fa0e11f5d973b5 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html#ae84f817a09e9205af9fa0e11f5d973b5">AssociatedHandler</a><code> [get]</code></td></tr>
<tr class="memdesc:ae84f817a09e9205af9fa0e11f5d973b5 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computation handler associated with this traceable object (null if none).  <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html#ae84f817a09e9205af9fa0e11f5d973b5">More...</a><br /></td></tr>
<tr class="separator:ae84f817a09e9205af9fa0e11f5d973b5 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An n-dimensional array of any data type with C-like ordering. Includes utility functions for scalar, vector and matrix manipulation. </p>
<p>Why does <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html" title="An n-dimensional array of any data type with C-like ordering. Includes utility functions for scalar...">INDArray</a> not expose the underlying data? Not exposing the internal data directly makes it easier to define the general workflow of how INDArrays should interact in an algorithm without having to think about underlying system data types. That also allows anyone to roll their own implementation, defining where data is stored and how it is processed (System memory, GPU cache, the moon (beware of latency issues, batch calculations), ...). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a74af7dbdbf9453beedefa2d6d5fd6375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74af7dbdbf9453beedefa2d6d5fd6375">&#9670;&nbsp;</a></span>Flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.MathAbstract.INDArray.Flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a NEW flattened ndarray with the same data but a flat shape (row vector). </p>
<dl class="section return"><dt>Returns</dt><dd>A NEW flattened ndarray with the same data.</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a9f4ec1d9c85581cd59b909aa29fe987e">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a6b4426b31633f4d8b46cfe8af864a8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4426b31633f4d8b46cfe8af864a8e6">&#9670;&nbsp;</a></span>FlattenSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.MathAbstract.INDArray.FlattenSelf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten THIS ndarray to a flat row vector. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a14203f458479cf932d4f50c0754d98d6">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a11f923a488660b89ad4cbf910a39f42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f923a488660b89ad4cbf910a39f42c">&#9670;&nbsp;</a></span>GetDataAs< TOther >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_i_data_buffer.html">IDataBuffer</a>&lt;TOther&gt; Sigma.Core.MathAbstract.INDArray.GetDataAs&lt; TOther &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a COPY of the underlying data buffer as a certain data type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOther</td><td>The type the buffer should have.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data buffer with the given data type.</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#acbfce8d075821cc3b434fb629dd551a4">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a9aed17ce39ec790b3bad7e146f042903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aed17ce39ec790b3bad7e146f042903">&#9670;&nbsp;</a></span>GetValue< TOther >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TOther Sigma.Core.MathAbstract.INDArray.GetValue&lt; TOther &gt; </td>
          <td>(</td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a value at a certain index as a certain type. Note: The value might have to be internally explicitly cast to the requested type (and thereby change). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOther</td><td>The type the value should have.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the given index as the given type.</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a5ee09cf795a8827fdf0757253f44b1c3">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="acd26fddf232c4c1d3d6459f14fafcddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd26fddf232c4c1d3d6459f14fafcddb">&#9670;&nbsp;</a></span>Permute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.MathAbstract.INDArray.Permute </td>
          <td>(</td>
          <td class="paramtype">params int []&#160;</td>
          <td class="paramname"><em>rearrangedDimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a NEW ndarray with the same data but another permuted shape (and also different strides). Permutation occurs according to the content of the rearranged dimensions array, where each element represents the number of a dimension to swap with. The permutation array has to have the same number of dimensions as the actual shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rearrangedDimensions</td><td>The dimensions to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NEW ndarray with the same data and a new permuted shape.</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#ada5b0f22e1821e91b7775d38a79517a3">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a1d870bf4c4a940eaebb6b1edf8c60558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d870bf4c4a940eaebb6b1edf8c60558">&#9670;&nbsp;</a></span>PermuteSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.MathAbstract.INDArray.PermuteSelf </td>
          <td>(</td>
          <td class="paramtype">params int []&#160;</td>
          <td class="paramname"><em>rearrangedDimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permute THIS ndarray to another permuted shape (and also different strides). Permutation occurs according to the content of the rearranged dimensions array, where each element represents the number of a dimension to swap with. The permutation array has to have the same number of dimensions as the actual shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rearrangedDimensions</td><td>The dimensions to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This ndarray (for convenience).</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a72bafb14bcad33f63a68aa83e4a3bcf1">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a811f9ab94bae55a882fef7f2f2462fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811f9ab94bae55a882fef7f2f2462fca">&#9670;&nbsp;</a></span>Reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.MathAbstract.INDArray.Reshape </td>
          <td>(</td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>newShape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a NEW ndarray with the same data but another shape (and different strides). Note: The total length of the ndarray cannot change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newShape</td><td>The new shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NEW ndarray with the same data and the given shape.</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a2d4d39a955a0e85467877ac29c1ec32d">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="aa0d8cdce99b5d58221dbb71bd06c5ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d8cdce99b5d58221dbb71bd06c5ae0">&#9670;&nbsp;</a></span>ReshapeSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.MathAbstract.INDArray.ReshapeSelf </td>
          <td>(</td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>newShape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshape THIS ndarray to a new shape (this operation also changes strides). Note: The total length of the ndarray cannot change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newShape</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This ndarray (for convenience).</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#af1f4052dd979755b444fde997d9866b9">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a7ff221e48e75e5de20c6cae58a59cf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff221e48e75e5de20c6cae58a59cf0f">&#9670;&nbsp;</a></span>SetValue< TOther >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sigma.Core.MathAbstract.INDArray.SetValue&lt; TOther &gt; </td>
          <td>(</td>
          <td class="paramtype">TOther&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a value of a certain type at a certain index. Note: The value might have to be internally explicitly cast to the internally used type (and thereby change). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOther</td><td>The type of the given value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value.</td></tr>
    <tr><td class="paramname">indices</td><td>The indices.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a041ead10c711130003900e1e5439cb33">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a89d893a6ca95de9a04cbd2972391af3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d893a6ca95de9a04cbd2972391af3a">&#9670;&nbsp;</a></span>Slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.MathAbstract.INDArray.Slice </td>
          <td>(</td>
          <td class="paramtype">long []&#160;</td>
          <td class="paramname"><em>beginIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long []&#160;</td>
          <td class="paramname"><em>endIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a slice of this ndarray of a certain region as a new ndarray with the same underlying data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginIndices</td><td>The begin indices (inclusively, where the slice should begin).</td></tr>
    <tr><td class="paramname">endIndices</td><td>The end indices (exclusively, where the slice should end).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a83a8d01e6a4535724af52b0b5654391c">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a34bd3d64fde5e14da25c90cac2e0a588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bd3d64fde5e14da25c90cac2e0a588">&#9670;&nbsp;</a></span>Transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.MathAbstract.INDArray.Transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a NEW ndarray with the same data but transposed (reversed dimensions). </p>
<dl class="section return"><dt>Returns</dt><dd>A NEW ndarray with the same data but transposed (reversed dimensions).</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a99af18400583b1eec6e0fc9221e68d72">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a7a91147f2ab41c01e4c33d0d9213d7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a91147f2ab41c01e4c33d0d9213d7b9">&#9670;&nbsp;</a></span>TransposeSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> Sigma.Core.MathAbstract.INDArray.TransposeSelf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose THIS ndarray (reverse dimensions). </p>
<dl class="section return"><dt>Returns</dt><dd>This ndarray (for convenience).</dd></dl>

<p>Implemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a188c7d115692d434a3e102d12b7e70d0">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a92feaa5c25202385ef35b6c671aed207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92feaa5c25202385ef35b6c671aed207">&#9670;&nbsp;</a></span>IsMatrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.MathAbstract.INDArray.IsMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience flag indicating if this ndarray is a matrix (i.e. if its shape is 2-dimensional) </p>

</div>
</div>
<a id="a2dcae99a669db63943952a3b510746df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcae99a669db63943952a3b510746df">&#9670;&nbsp;</a></span>IsScalar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.MathAbstract.INDArray.IsScalar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience flag indicating if this ndarray is a scalar (i.e. if its shape is {1}) </p>

</div>
</div>
<a id="aa42319c4b5ed047c8de183405d7c7f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42319c4b5ed047c8de183405d7c7f7c">&#9670;&nbsp;</a></span>IsVector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.MathAbstract.INDArray.IsVector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience flag indicating if this ndarray is a vector (i.e. if its shape is 1-dimensional) </p>

</div>
</div>
<a id="a2b156ef66492a0054a48dd7609f8a4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b156ef66492a0054a48dd7609f8a4f7">&#9670;&nbsp;</a></span>Length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Sigma.Core.MathAbstract.INDArray.Length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The length of this ndarray (total number of elements). </p>

</div>
</div>
<a id="ac2f79ed481caeac8e89285c8628521af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f79ed481caeac8e89285c8628521af">&#9670;&nbsp;</a></span>Rank</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Sigma.Core.MathAbstract.INDArray.Rank</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rank of this ndarray (number of dimensions). </p>

</div>
</div>
<a id="af509c6a88045887f085da4a4a73f2c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af509c6a88045887f085da4a4a73f2c60">&#9670;&nbsp;</a></span>Shape</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long [] Sigma.Core.MathAbstract.INDArray.Shape</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The shape of this ndarray (i.e. the dimensions). </p>

</div>
</div>
<a id="ab13cd0073779c6083843e1d69b031605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13cd0073779c6083843e1d69b031605">&#9670;&nbsp;</a></span>Strides</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long [] Sigma.Core.MathAbstract.INDArray.Strides</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The strides of this ndarray. A stride at any dimension defines how many elements to skip to move to the next element along that dimension. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>C:/Users/Plainer/Documents/GitHub/Sigma/Sigma.Core/MathAbstract/INDArray.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
