<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sigma: Sigma.Core.Data.Datasets.Dataset Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="128x128.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sigma
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_sigma.html">Sigma</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core.html">Core</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_data.html">Data</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_data_1_1_datasets.html">Datasets</a></li><li class="navelem"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html">Dataset</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sigma.Core.Data.Datasets.Dataset Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A default implementation of the <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html" title="A dataset representing a collection of record blocks, where blocks can be ">IDataset</a> interface. Provides caching of entire blocks and reader data, partial extraction, unordered extraction, automatic block sizing, smart block loading.  
 <a href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Sigma.Core.Data.Datasets.Dataset:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.png" usemap="#Sigma.Core.Data.Datasets.Dataset_map" alt=""/>
  <map id="Sigma.Core.Data.Datasets.Dataset_map" name="Sigma.Core.Data.Datasets.Dataset_map">
<area href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html" title="A dataset representing a collection of record blocks, where blocks can be " alt="Sigma.Core.Data.Datasets.IDataset" shape="rect" coords="0,56,209,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>RecordBlock</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>RecordBlockBase</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>WeakRecordBlock</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afde18303858b82e9af65673b1e46ef19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#afde18303858b82e9af65673b1e46ef19">Dataset</a> (string name, params <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_extractors_1_1_i_record_extractor.html">IRecordExtractor</a>[] recordExtractors)</td></tr>
<tr class="memdesc:afde18303858b82e9af65673b1e46ef19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dataset with a certain unique name and the record extractors to use.  <a href="#afde18303858b82e9af65673b1e46ef19">More...</a><br /></td></tr>
<tr class="separator:afde18303858b82e9af65673b1e46ef19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88c7406c798656e23778023d0c2bd52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#ae88c7406c798656e23778023d0c2bd52">Dataset</a> (string name, int blockSizeRecords, params <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_extractors_1_1_i_record_extractor.html">IRecordExtractor</a>[] recordExtractors)</td></tr>
<tr class="memdesc:ae88c7406c798656e23778023d0c2bd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dataset with a certain unique name, target block size in records and the record extractors to use.  <a href="#ae88c7406c798656e23778023d0c2bd52">More...</a><br /></td></tr>
<tr class="separator:ae88c7406c798656e23778023d0c2bd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dcd61ac9f7c8c99aa9a22b880e3a9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a47dcd61ac9f7c8c99aa9a22b880e3a9d">Dataset</a> (string name, int blockSizeRecords, <a class="el" href="interface_sigma_1_1_core_1_1_utils_1_1_i_cache_provider.html">ICacheProvider</a> cacheProvider, bool flushCache=true, params <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_extractors_1_1_i_record_extractor.html">IRecordExtractor</a>[] recordExtractors)</td></tr>
<tr class="memdesc:a47dcd61ac9f7c8c99aa9a22b880e3a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dataset with a certain unique name, target block size in records, specific cache provider and the record extractors to use.  <a href="#a47dcd61ac9f7c8c99aa9a22b880e3a9d">More...</a><br /></td></tr>
<tr class="separator:a47dcd61ac9f7c8c99aa9a22b880e3a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145c28fa1524608dd8dd82a10f5e06d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a145c28fa1524608dd8dd82a10f5e06d1">SplitBlockwise</a> (params int[] parts)</td></tr>
<tr class="memdesc:a145c28fa1524608dd8dd82a10f5e06d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split this dataset block-wise into certain parts.  <a href="#a145c28fa1524608dd8dd82a10f5e06d1">More...</a><br /></td></tr>
<tr class="separator:a145c28fa1524608dd8dd82a10f5e06d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedfe54f2561576203e7e025e92f72d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#aeedfe54f2561576203e7e025e92f72d8">SplitRecordwise</a> (params double[] parts)</td></tr>
<tr class="memdesc:aeedfe54f2561576203e7e025e92f72d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the dataset record-wise into certain parts.  <a href="#aeedfe54f2561576203e7e025e92f72d8">More...</a><br /></td></tr>
<tr class="separator:aeedfe54f2561576203e7e025e92f72d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1042d77af44646d0f0f27bd1ae4a6730"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a1042d77af44646d0f0f27bd1ae4a6730">TrySetBlockSize</a> (int blockSizeRecords)</td></tr>
<tr class="memdesc:a1042d77af44646d0f0f27bd1ae4a6730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to set the block size to a new block size if compatible with the current set block size (e.g. if was auto set and this is the first request).  <a href="#a1042d77af44646d0f0f27bd1ae4a6730">More...</a><br /></td></tr>
<tr class="separator:a1042d77af44646d0f0f27bd1ae4a6730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b21ee1f403bbe227c17a5b9c01f907"><td class="memItemLeft" align="right" valign="top"><a id="aa9b21ee1f403bbe227c17a5b9c01f907"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetNumberOfLoadedInactiveCachedBlocks</b> ()</td></tr>
<tr class="separator:aa9b21ee1f403bbe227c17a5b9c01f907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dfc3d9036e0bd8c7d894c8c166e66c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#aa6dfc3d9036e0bd8c7d894c8c166e66c">CanFetchBlocksAfter</a> (int blockIndex)</td></tr>
<tr class="memdesc:aa6dfc3d9036e0bd8c7d894c8c166e66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether any more blocks can be fetched after a specified block index.  <a href="#aa6dfc3d9036e0bd8c7d894c8c166e66c">More...</a><br /></td></tr>
<tr class="separator:aa6dfc3d9036e0bd8c7d894c8c166e66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6157bd931866affad69243e4263ea515"><td class="memItemLeft" align="right" valign="top">async Task&lt; IDictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a6157bd931866affad69243e4263ea515">FetchBlockAsync</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler, bool shouldWaitUntilAvailable=true)</td></tr>
<tr class="memdesc:a6157bd931866affad69243e4263ea515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a record block with a certain index for a certain computation handler asynchronously. Load, prepare and convert the requested block to the format required by a certain handler unless it was already fetched and is still active in that format. If the specified block can currently not be loaded due to memory constraints (as specified in MaxConcurrentActiveBlocks and MaxTotalActiveBlockSizeBytes):  <a href="#a6157bd931866affad69243e4263ea515">More...</a><br /></td></tr>
<tr class="separator:a6157bd931866affad69243e4263ea515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1cc7952852b2f2add01080b48186f2"><td class="memItemLeft" align="right" valign="top">IDictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a0c1cc7952852b2f2add01080b48186f2">FetchBlock</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler, bool shouldWaitUntilAvailable=true)</td></tr>
<tr class="memdesc:a0c1cc7952852b2f2add01080b48186f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch named record block with a certain index for a certain computation handler. Load, prepare and convert the requested block to the format required by a certain handler unless it was already fetched and is still active in that format. If the specified block can currently not be loaded due to memory constraints (as specified in MaxConcurrentActiveBlocks and MaxTotalActiveBlockSizeBytes):  <a href="#a0c1cc7952852b2f2add01080b48186f2">More...</a><br /></td></tr>
<tr class="separator:a0c1cc7952852b2f2add01080b48186f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af135c5aa3fdff08d4152851af65e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a5af135c5aa3fdff08d4152851af65e4c">InvalidateAndClearCaches</a> ()</td></tr>
<tr class="memdesc:a5af135c5aa3fdff08d4152851af65e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate and clear all caches associated with this dataset. WARNING: Removing cache entries may cause certain datasets to load much more slowly or incorrectly. Use cases include removing cache entries for old datasets or datasets with different extractors.  <a href="#a5af135c5aa3fdff08d4152851af65e4c">More...</a><br /></td></tr>
<tr class="separator:a5af135c5aa3fdff08d4152851af65e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4762dade87ed9b328ada1634b06dea9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a4762dade87ed9b328ada1634b06dea9c">FreeBlock</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:a4762dade87ed9b328ada1634b06dea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a record block with a certain index associated with the given handler. If all other references to that block index in other formats are freed, the entire block is unloaded (freed) and set to inactive.  <a href="#a4762dade87ed9b328ada1634b06dea9c">More...</a><br /></td></tr>
<tr class="separator:a4762dade87ed9b328ada1634b06dea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1a6d8295e0c3b1afdd98583e37283f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#ada1a6d8295e0c3b1afdd98583e37283f">GetBlockSizeBytes</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:ada1a6d8295e0c3b1afdd98583e37283f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (estimated) size of a block in system memory with a certain index and handler format in bytes.  <a href="#ada1a6d8295e0c3b1afdd98583e37283f">More...</a><br /></td></tr>
<tr class="separator:ada1a6d8295e0c3b1afdd98583e37283f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76510499edcf5a9027111cb3e58814c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a76510499edcf5a9027111cb3e58814c1">IsBlockActive</a> (int blockIndex)</td></tr>
<tr class="memdesc:a76510499edcf5a9027111cb3e58814c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a certain block index is currently active and loaded in any format.  <a href="#a76510499edcf5a9027111cb3e58814c1">More...</a><br /></td></tr>
<tr class="separator:a76510499edcf5a9027111cb3e58814c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5382d88a756da285a1fd653bf1dbec06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a5382d88a756da285a1fd653bf1dbec06">IsBlockActive</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:a5382d88a756da285a1fd653bf1dbec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a certain block index is currently active and loaded in a certain handler format.  <a href="#a5382d88a756da285a1fd653bf1dbec06">More...</a><br /></td></tr>
<tr class="separator:a5382d88a756da285a1fd653bf1dbec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6720a0de8e872320f03029151a1139e2"><td class="memItemLeft" align="right" valign="top"><a id="a6720a0de8e872320f03029151a1139e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Dispose</b> ()</td></tr>
<tr class="separator:a6720a0de8e872320f03029151a1139e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2924a32d5771db06ad8b238c4b823c8a"><td class="memItemLeft" align="right" valign="top"><a id="a2924a32d5771db06ad8b238c4b823c8a"></a>
static <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> []&#160;</td><td class="memItemRight" valign="bottom"><b>SplitBlockwise</b> (<a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> dataset, params int[] parts)</td></tr>
<tr class="separator:a2924a32d5771db06ad8b238c4b823c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c80f18155b690fad9b38873375c68f7"><td class="memItemLeft" align="right" valign="top"><a id="a3c80f18155b690fad9b38873375c68f7"></a>
static <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> []&#160;</td><td class="memItemRight" valign="bottom"><b>SplitRecordwise</b> (<a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> dataset, params double[] parts)</td></tr>
<tr class="separator:a3c80f18155b690fad9b38873375c68f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2f28f7ec7eccb136af6c428685c98517"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a2f28f7ec7eccb136af6c428685c98517">BlockSizeAuto</a> = -1</td></tr>
<tr class="memdesc:a2f28f7ec7eccb136af6c428685c98517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically size blocks according to estimated data metrics (e.g. physical memory available, record size).  <a href="#a2f28f7ec7eccb136af6c428685c98517">More...</a><br /></td></tr>
<tr class="separator:a2f28f7ec7eccb136af6c428685c98517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab7e6f6125e590d9f4526095b3ee90e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#abab7e6f6125e590d9f4526095b3ee90e">BlockSizeAll</a> = -2</td></tr>
<tr class="memdesc:abab7e6f6125e590d9f4526095b3ee90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign all available data to the first block (one block fits it all - literally).  <a href="#abab7e6f6125e590d9f4526095b3ee90e">More...</a><br /></td></tr>
<tr class="separator:abab7e6f6125e590d9f4526095b3ee90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59b3c21b72a7a06b21f45d27cb51c7e"><td class="memItemLeft" align="right" valign="top"><a id="ac59b3c21b72a7a06b21f45d27cb51c7e"></a>
IReadOnlyCollection&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ActiveBlockIndices</b> =&gt; _activeBlocks.Keys.ToList()</td></tr>
<tr class="separator:ac59b3c21b72a7a06b21f45d27cb51c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7825f88704c6e44a8d1d374ad66bb3a2"><td class="memItemLeft" align="right" valign="top"><a id="a7825f88704c6e44a8d1d374ad66bb3a2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ActiveBlockRegionCount</b> =&gt; _activeBlocks.Count</td></tr>
<tr class="separator:a7825f88704c6e44a8d1d374ad66bb3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ab0acb567718ff9d339f4600cc7486854"><td class="memItemLeft" align="right" valign="top"><a id="ab0acb567718ff9d339f4600cc7486854"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxConcurrentActiveBlocks</b><code> [get]</code></td></tr>
<tr class="separator:ab0acb567718ff9d339f4600cc7486854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8477bfdce39d51065c8e571bbfbf32"><td class="memItemLeft" align="right" valign="top"><a id="adc8477bfdce39d51065c8e571bbfbf32"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>MaxTotalActiveBlockSizeBytes</b> = 24<code> [get]</code></td></tr>
<tr class="separator:adc8477bfdce39d51065c8e571bbfbf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ead603307a8795a0b282bae2fc84ce"><td class="memItemLeft" align="right" valign="top"><a id="a09ead603307a8795a0b282bae2fc84ce"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>Name</b><code> [get]</code></td></tr>
<tr class="separator:a09ead603307a8795a0b282bae2fc84ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e06e857cd9accd1a18992fa021ca4e"><td class="memItemLeft" align="right" valign="top"><a id="a09e06e857cd9accd1a18992fa021ca4e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ActiveIndividualBlockCount</b><code> [get]</code></td></tr>
<tr class="separator:a09e06e857cd9accd1a18992fa021ca4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043f0fb8472b52a2cdf3b81e488dea0b"><td class="memItemLeft" align="right" valign="top"><a id="a043f0fb8472b52a2cdf3b81e488dea0b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TargetBlockSizeRecords</b><code> [get, private set]</code></td></tr>
<tr class="separator:a043f0fb8472b52a2cdf3b81e488dea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279fc577fe1fd242bbcc2b9278c490b2"><td class="memItemLeft" align="right" valign="top"><a id="a279fc577fe1fd242bbcc2b9278c490b2"></a>
string []&#160;</td><td class="memItemRight" valign="bottom"><b>SectionNames</b><code> [get, private set]</code></td></tr>
<tr class="separator:a279fc577fe1fd242bbcc2b9278c490b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f1f72c4826478ed9e1384d3f883ffe"><td class="memItemLeft" align="right" valign="top"><a id="a52f1f72c4826478ed9e1384d3f883ffe"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>TotalActiveBlockSizeBytes</b><code> [get, private set]</code></td></tr>
<tr class="separator:a52f1f72c4826478ed9e1384d3f883ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261d5cb1b76cbc08a270e842db09dbcd"><td class="memItemLeft" align="right" valign="top"><a id="a261d5cb1b76cbc08a270e842db09dbcd"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>TotalActiveRecords</b><code> [get, private set]</code></td></tr>
<tr class="separator:a261d5cb1b76cbc08a270e842db09dbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa019ba973ff083340e86d5e668797c41"><td class="memItemLeft" align="right" valign="top"><a id="aa019ba973ff083340e86d5e668797c41"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxBlocksInCache</b><code> [get, set]</code></td></tr>
<tr class="separator:aa019ba973ff083340e86d5e668797c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755943643b07544896a84ebbc8e3dd38"><td class="memItemLeft" align="right" valign="top"><a id="a755943643b07544896a84ebbc8e3dd38"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>MaxBytesInCache</b> = int.MaxValue<code> [get, set]</code></td></tr>
<tr class="separator:a755943643b07544896a84ebbc8e3dd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ccb77e43a9a8cd66c66f20303ac694"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a62ccb77e43a9a8cd66c66f20303ac694">AllowRawReadDataCaching</a> = long.MaxValue<code> [get, set]</code></td></tr>
<tr class="memdesc:a62ccb77e43a9a8cd66c66f20303ac694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether this dataset should cache the raw reader data. If disabled, only extracted data will be cached and once processed, it might be impossible to retrieve preceding record blocks (reader streams are assumed to be non-seekable).  <a href="#a62ccb77e43a9a8cd66c66f20303ac694">More...</a><br /></td></tr>
<tr class="separator:a62ccb77e43a9a8cd66c66f20303ac694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">Sigma.Core.Data.Datasets.IDataset</a></td></tr>
<tr class="memitem:af8c1a60d3478a2dafb4ebedf382d26f4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#af8c1a60d3478a2dafb4ebedf382d26f4">Name</a><code> [get]</code></td></tr>
<tr class="memdesc:af8c1a60d3478a2dafb4ebedf382d26f4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name and identifier of this dataset. <a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html" title="A default implementation of the IDataset interface. Provides caching of entire blocks and reader data...">Dataset</a> names should be globally unique and easily identifiable.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#af8c1a60d3478a2dafb4ebedf382d26f4">More...</a><br /></td></tr>
<tr class="separator:af8c1a60d3478a2dafb4ebedf382d26f4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2834cfa9c66324039efccbecf0db4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a4ef2834cfa9c66324039efccbecf0db4">TargetBlockSizeRecords</a><code> [get]</code></td></tr>
<tr class="memdesc:a4ef2834cfa9c66324039efccbecf0db4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The preferred per block size in records. Note: Not every block must obey this request (e.g. the last black might very well be a different size).  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a4ef2834cfa9c66324039efccbecf0db4">More...</a><br /></td></tr>
<tr class="separator:a4ef2834cfa9c66324039efccbecf0db4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fadf9aedcf24c2f45b9e73e63ccf97e inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a7fadf9aedcf24c2f45b9e73e63ccf97e">MaxConcurrentActiveBlocks</a><code> [get]</code></td></tr>
<tr class="memdesc:a7fadf9aedcf24c2f45b9e73e63ccf97e inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of concurrently active blocks.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a7fadf9aedcf24c2f45b9e73e63ccf97e">More...</a><br /></td></tr>
<tr class="separator:a7fadf9aedcf24c2f45b9e73e63ccf97e inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41b6b52f00ddbe6d8666d343a4e0531 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ad41b6b52f00ddbe6d8666d343a4e0531">MaxTotalActiveBlockSizeBytes</a><code> [get]</code></td></tr>
<tr class="memdesc:ad41b6b52f00ddbe6d8666d343a4e0531 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum total concurrently active block size in bytes.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ad41b6b52f00ddbe6d8666d343a4e0531">More...</a><br /></td></tr>
<tr class="separator:ad41b6b52f00ddbe6d8666d343a4e0531 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75256c09fd644adeab6e58cd2a230f0 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ab75256c09fd644adeab6e58cd2a230f0">TotalActiveBlockSizeBytes</a><code> [get]</code></td></tr>
<tr class="memdesc:ab75256c09fd644adeab6e58cd2a230f0 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total size of all currently active record blocks in system memory in bytes.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ab75256c09fd644adeab6e58cd2a230f0">More...</a><br /></td></tr>
<tr class="separator:ab75256c09fd644adeab6e58cd2a230f0 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19e86c464cebb60f2bc83c4961beaaa inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ab19e86c464cebb60f2bc83c4961beaaa">MaxBlocksInCache</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ab19e86c464cebb60f2bc83c4961beaaa inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maxmimum number of blocks to keep in the cache (inactive blocks are written to a cache, typically on disk, to be reloaded later).  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ab19e86c464cebb60f2bc83c4961beaaa">More...</a><br /></td></tr>
<tr class="separator:ab19e86c464cebb60f2bc83c4961beaaa inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef69f54df7d1d84d99ebb9d97602f135 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aef69f54df7d1d84d99ebb9d97602f135">MaxBytesInCache</a><code> [get, set]</code></td></tr>
<tr class="memdesc:aef69f54df7d1d84d99ebb9d97602f135 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maxmimum number of bytes to keep in the cache (inactive blocks are written to a cache, typically on disk, to be reloaded later).  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aef69f54df7d1d84d99ebb9d97602f135">More...</a><br /></td></tr>
<tr class="separator:aef69f54df7d1d84d99ebb9d97602f135 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef5942f34f79da6c11ca263caf998d8 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">string []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aeef5942f34f79da6c11ca263caf998d8">SectionNames</a><code> [get]</code></td></tr>
<tr class="memdesc:aeef5942f34f79da6c11ca263caf998d8 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The names for all sections present in this dataset (e.g. "inputs", "targets").  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aeef5942f34f79da6c11ca263caf998d8">More...</a><br /></td></tr>
<tr class="separator:aeef5942f34f79da6c11ca263caf998d8 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae460b7cfe55b278c511956933cd243ee inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">IReadOnlyCollection&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ae460b7cfe55b278c511956933cd243ee">ActiveBlockIndices</a><code> [get]</code></td></tr>
<tr class="memdesc:ae460b7cfe55b278c511956933cd243ee inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of currently active and loaded record block indices.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ae460b7cfe55b278c511956933cd243ee">More...</a><br /></td></tr>
<tr class="separator:ae460b7cfe55b278c511956933cd243ee inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9631159c8c2d65d2fe3efafc599c83 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aeb9631159c8c2d65d2fe3efafc599c83">ActiveIndividualBlockCount</a><code> [get]</code></td></tr>
<tr class="memdesc:aeb9631159c8c2d65d2fe3efafc599c83 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of currently active and loaded record blocks, with different block formats counting as different blocks.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aeb9631159c8c2d65d2fe3efafc599c83">More...</a><br /></td></tr>
<tr class="separator:aeb9631159c8c2d65d2fe3efafc599c83 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaba4340f92392f7724f90270eda47a inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#abfaba4340f92392f7724f90270eda47a">ActiveBlockRegionCount</a><code> [get]</code></td></tr>
<tr class="memdesc:abfaba4340f92392f7724f90270eda47a inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of currently active and loaded record blocks, with different block formats of the same region counting as one active block index.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#abfaba4340f92392f7724f90270eda47a">More...</a><br /></td></tr>
<tr class="separator:abfaba4340f92392f7724f90270eda47a inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7b30b47635a0255dc2628705e4faf67d"><td class="memItemLeft" align="right" valign="top"><a id="a7b30b47635a0255dc2628705e4faf67d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AnalyseExtractors</b> (IEnumerable&lt; <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_extractors_1_1_i_record_extractor.html">IRecordExtractor</a> &gt; extractors)</td></tr>
<tr class="separator:a7b30b47635a0255dc2628705e4faf67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5239aca098142658ae86f569dbd8bab0"><td class="memItemLeft" align="right" valign="top"><a id="a5239aca098142658ae86f569dbd8bab0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterActiveBlock</b> (Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt; block, int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:a5239aca098142658ae86f569dbd8bab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7fe2c5a4172e208fce9564dd67caa5"><td class="memItemLeft" align="right" valign="top"><a id="a6e7fe2c5a4172e208fce9564dd67caa5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeregisterActiveBlock</b> (RecordBlock recordBlock)</td></tr>
<tr class="separator:a6e7fe2c5a4172e208fce9564dd67caa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84463d5f843b7e94293a7fd09c70303"><td class="memItemLeft" align="right" valign="top"><a id="ae84463d5f843b7e94293a7fd09c70303"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterCachedBlock</b> (Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt; block, int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler, bool keepReference)</td></tr>
<tr class="separator:ae84463d5f843b7e94293a7fd09c70303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc1af393ba29054f7730b1e0ba5bc77"><td class="memItemLeft" align="right" valign="top"><a id="abdc1af393ba29054f7730b1e0ba5bc77"></a>
Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FetchBlockWhenAvailable</b> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:abdc1af393ba29054f7730b1e0ba5bc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ae36f44bf4b3691d95d6a589095433"><td class="memItemLeft" align="right" valign="top"><a id="a82ae36f44bf4b3691d95d6a589095433"></a>
Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FetchBlockConstrained</b> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:a82ae36f44bf4b3691d95d6a589095433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26a9cbb531de41c15fad76019f103f8"><td class="memItemLeft" align="right" valign="top"><a id="ad26a9cbb531de41c15fad76019f103f8"></a>
Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LoadAndExtractBlockWhenAvailable</b> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:ad26a9cbb531de41c15fad76019f103f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae224a680453a4bbcb33e3e9af5894a0e"><td class="memItemLeft" align="right" valign="top"><a id="ae224a680453a4bbcb33e3e9af5894a0e"></a>
Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBestMatchedBlockWhenAvailable</b> (IEnumerable&lt; RecordBlockBase &gt; blocks, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:ae224a680453a4bbcb33e3e9af5894a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fea32d49c5dd3dddad558e851cf320"><td class="memItemLeft" align="right" valign="top"><a id="a21fea32d49c5dd3dddad558e851cf320"></a>
Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LoadAndExtractRaw</b> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:a21fea32d49c5dd3dddad558e851cf320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24d83285c5eba28eaa9e88f8762d3cb"><td class="memItemLeft" align="right" valign="top"><a id="aa24d83285c5eba28eaa9e88f8762d3cb"></a>
object []&#160;</td><td class="memItemRight" valign="bottom"><b>LoadDirect</b> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:aa24d83285c5eba28eaa9e88f8762d3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea37f76ec0a72280fa21c308e60ad14e"><td class="memItemLeft" align="right" valign="top"><a id="aea37f76ec0a72280fa21c308e60ad14e"></a>
Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractDirectFrom</b> (object[] data, int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:aea37f76ec0a72280fa21c308e60ad14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463ef82c22d45dcce17d076e8b56f3ba"><td class="memItemLeft" align="right" valign="top"><a id="a463ef82c22d45dcce17d076e8b56f3ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CacheBlockConstrained</b> (Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt; block, int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:a463ef82c22d45dcce17d076e8b56f3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff637c4707028b8f0e70b6919a5b0e4f"><td class="memItemLeft" align="right" valign="top"><a id="aff637c4707028b8f0e70b6919a5b0e4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrepareExtractors</b> ()</td></tr>
<tr class="separator:aff637c4707028b8f0e70b6919a5b0e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbeb6683d1770f931b6364943706d62"><td class="memItemLeft" align="right" valign="top"><a id="a6cbeb6683d1770f931b6364943706d62"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsBlockCached</b> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:a6cbeb6683d1770f931b6364943706d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ac163810c7b0eb25a6c4f1490611aa84b"><td class="memItemLeft" align="right" valign="top"><a id="ac163810c7b0eb25a6c4f1490611aa84b"></a>
static Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertNamedBlocks</b> (Dictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt; namedBlockSections, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="separator:ac163810c7b0eb25a6c4f1490611aa84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a20521555bbf98b18b642fbe1f821f7f5"><td class="memItemLeft" align="right" valign="top"><a id="a20521555bbf98b18b642fbe1f821f7f5"></a>
readonly ILog&#160;</td><td class="memItemRight" valign="bottom"><b>_logger</b> = LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType)</td></tr>
<tr class="separator:a20521555bbf98b18b642fbe1f821f7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2e3cdecddd510bc5d963dcf2cb9150"><td class="memItemLeft" align="right" valign="top"><a id="a8d2e3cdecddd510bc5d963dcf2cb9150"></a>
readonly Dictionary&lt; int, ISet&lt; RecordBlock &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_activeBlocks</b> = true</td></tr>
<tr class="separator:a8d2e3cdecddd510bc5d963dcf2cb9150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85883b5dd553de247910cc341b6da015"><td class="memItemLeft" align="right" valign="top"><a id="a85883b5dd553de247910cc341b6da015"></a>
readonly Dictionary&lt; int, ISet&lt; WeakRecordBlock &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_cachedBlocks</b></td></tr>
<tr class="separator:a85883b5dd553de247910cc341b6da015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888c8264e299f1d71b79751f653bd57b"><td class="memItemLeft" align="right" valign="top"><a id="a888c8264e299f1d71b79751f653bd57b"></a>
readonly <a class="el" href="interface_sigma_1_1_core_1_1_utils_1_1_i_cache_provider.html">ICacheProvider</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_cacheProvider</b></td></tr>
<tr class="separator:a888c8264e299f1d71b79751f653bd57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1122f2db8e07cc65c3caccb6105a28bc"><td class="memItemLeft" align="right" valign="top"><a id="a1122f2db8e07cc65c3caccb6105a28bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_lastReadRawDataBlockIndex</b> = -1</td></tr>
<tr class="separator:a1122f2db8e07cc65c3caccb6105a28bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8250b7692fbdb23e91df63114be634d3"><td class="memItemLeft" align="right" valign="top"><a id="a8250b7692fbdb23e91df63114be634d3"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>_totalCachedBlockSizeBytes</b></td></tr>
<tr class="separator:a8250b7692fbdb23e91df63114be634d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5896e77c5c6285a5cdc2e3e69bf03be0"><td class="memItemLeft" align="right" valign="top"><a id="a5896e77c5c6285a5cdc2e3e69bf03be0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_lastAvailableBlockIndex</b> = int.MaxValue</td></tr>
<tr class="separator:a5896e77c5c6285a5cdc2e3e69bf03be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49bc8714aef229fd8c6fb03bdc3b969"><td class="memItemLeft" align="right" valign="top"><a id="ae49bc8714aef229fd8c6fb03bdc3b969"></a>
readonly ISet&lt; <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_extractors_1_1_i_record_extractor.html">IRecordExtractor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_recordExtractors</b></td></tr>
<tr class="separator:ae49bc8714aef229fd8c6fb03bdc3b969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeca4742049566fbfe55b736f95aa9fc"><td class="memItemLeft" align="right" valign="top"><a id="abeca4742049566fbfe55b736f95aa9fc"></a>
readonly bool&#160;</td><td class="memItemRight" valign="bottom"><b>_autoSetBlockSize</b></td></tr>
<tr class="separator:abeca4742049566fbfe55b736f95aa9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89c3c81e8b3c6644cf2c37a621dc63"><td class="memItemLeft" align="right" valign="top"><a id="a7a89c3c81e8b3c6644cf2c37a621dc63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_autoSetExternalChangeBlockSize</b></td></tr>
<tr class="separator:a7a89c3c81e8b3c6644cf2c37a621dc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add972bdd8e716130cc04f87ffeaf3ad9"><td class="memItemLeft" align="right" valign="top"><a id="add972bdd8e716130cc04f87ffeaf3ad9"></a>
readonly Semaphore&#160;</td><td class="memItemRight" valign="bottom"><b>_availableBlocksSemaphore</b></td></tr>
<tr class="separator:add972bdd8e716130cc04f87ffeaf3ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d961466908a196819141e41fd00b93"><td class="memItemLeft" align="right" valign="top"><a id="a82d961466908a196819141e41fd00b93"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_availableBlocksSemaphoreState</b></td></tr>
<tr class="separator:a82d961466908a196819141e41fd00b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A default implementation of the <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html" title="A dataset representing a collection of record blocks, where blocks can be ">IDataset</a> interface. Provides caching of entire blocks and reader data, partial extraction, unordered extraction, automatic block sizing, smart block loading. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afde18303858b82e9af65673b1e46ef19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde18303858b82e9af65673b1e46ef19">&#9670;&nbsp;</a></span>Dataset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sigma.Core.Data.Datasets.Dataset.Dataset </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_extractors_1_1_i_record_extractor.html">IRecordExtractor</a> []&#160;</td>
          <td class="paramname"><em>recordExtractors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dataset with a certain unique name and the record extractors to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The unique dataset name.</td></tr>
    <tr><td class="paramname">recordExtractors</td><td>The record extractors to fetch the data from, which provide the dataset with ready to use record blocks.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae88c7406c798656e23778023d0c2bd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88c7406c798656e23778023d0c2bd52">&#9670;&nbsp;</a></span>Dataset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sigma.Core.Data.Datasets.Dataset.Dataset </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSizeRecords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_extractors_1_1_i_record_extractor.html">IRecordExtractor</a> []&#160;</td>
          <td class="paramname"><em>recordExtractors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dataset with a certain unique name, target block size in records and the record extractors to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The unique dataset name.</td></tr>
    <tr><td class="paramname">blockSizeRecords</td><td>The target block size for records. May also be <a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a2f28f7ec7eccb136af6c428685c98517" title="Automatically size blocks according to estimated data metrics (e.g. physical memory available...">BlockSizeAuto</a> or <a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#abab7e6f6125e590d9f4526095b3ee90e" title="Assign all available data to the first block (one block fits it all - literally). ...">BlockSizeAll</a>.</td></tr>
    <tr><td class="paramname">recordExtractors</td><td>The record extractors to fetch the data from, which provide the dataset with ready to use record blocks.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47dcd61ac9f7c8c99aa9a22b880e3a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dcd61ac9f7c8c99aa9a22b880e3a9d">&#9670;&nbsp;</a></span>Dataset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sigma.Core.Data.Datasets.Dataset.Dataset </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSizeRecords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_utils_1_1_i_cache_provider.html">ICacheProvider</a>&#160;</td>
          <td class="paramname"><em>cacheProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushCache</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_extractors_1_1_i_record_extractor.html">IRecordExtractor</a> []&#160;</td>
          <td class="paramname"><em>recordExtractors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dataset with a certain unique name, target block size in records, specific cache provider and the record extractors to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The unique dataset name.</td></tr>
    <tr><td class="paramname">blockSizeRecords</td><td>The target block size for records. May also be <a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#a2f28f7ec7eccb136af6c428685c98517" title="Automatically size blocks according to estimated data metrics (e.g. physical memory available...">BlockSizeAuto</a> or <a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html#abab7e6f6125e590d9f4526095b3ee90e" title="Assign all available data to the first block (one block fits it all - literally). ...">BlockSizeAll</a>.</td></tr>
    <tr><td class="paramname">cacheProvider</td><td>The cache provider to use for caching record blocks and raw reader data.</td></tr>
    <tr><td class="paramname">flushCache</td><td>Indicate whether the cache provider should be flushed (cleared) before use. Only disable if block size and extractors used do not change (otherwise undefined behaviour).</td></tr>
    <tr><td class="paramname">recordExtractors</td><td>The record extractors to fetch the data from, which provide the dataset with ready to use record blocks.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa6dfc3d9036e0bd8c7d894c8c166e66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dfc3d9036e0bd8c7d894c8c166e66c">&#9670;&nbsp;</a></span>CanFetchBlocksAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Data.Datasets.Dataset.CanFetchBlocksAfter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether any more blocks can be fetched after a specified block index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index after which to check for more blocks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ac2dee44bb005448443d02e2a1c5703a4">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a0c1cc7952852b2f2add01080b48186f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1cc7952852b2f2add01080b48186f2">&#9670;&nbsp;</a></span>FetchBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDictionary&lt;string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&gt; Sigma.Core.Data.Datasets.Dataset.FetchBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldWaitUntilAvailable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch named record block with a certain index for a certain computation handler. Load, prepare and convert the requested block to the format required by a certain handler unless it was already fetched and is still active in that format. If the specified block can currently not be loaded due to memory constraints (as specified in MaxConcurrentActiveBlocks and MaxTotalActiveBlockSizeBytes): </p>
<ul>
<li>If shouldWaitUntilAvailable flag is set: the calling thread will wait until the block becomes available, fetch the block and return it.</li>
<li>If shouldWaitUntilAvailable flag is not set: null will be returned. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The index of the record block to request.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler for which the block should be requested (specifies the block format).</td></tr>
    <tr><td class="paramname">shouldWaitUntilAvailable</td><td>Indicate if this method should wait for the specified block to become available or return null if it is not immediately available when called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A block record representing the named blocks at the given block index in the format required by the given handler or null if shouldWaitUntilAvailable is set to false and the specified block is unavailable.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aaa4f7b33e09f9dba6cd0a00f9a5813c8">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a6157bd931866affad69243e4263ea515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6157bd931866affad69243e4263ea515">&#9670;&nbsp;</a></span>FetchBlockAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">async Task&lt;IDictionary&lt;string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&gt; &gt; Sigma.Core.Data.Datasets.Dataset.FetchBlockAsync </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldWaitUntilAvailable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a record block with a certain index for a certain computation handler asynchronously. Load, prepare and convert the requested block to the format required by a certain handler unless it was already fetched and is still active in that format. If the specified block can currently not be loaded due to memory constraints (as specified in MaxConcurrentActiveBlocks and MaxTotalActiveBlockSizeBytes): </p>
<ul>
<li>If shouldWaitUntilAvailable flag is set: the task will asynchronously wait until the block becomes available, fetch the block and return it to the caller.</li>
<li>If shouldWaitUntilAvailable flag is not set: null will be returned immediately. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The index of the record block to request.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler for which the block should be requested (specifies the block format).</td></tr>
    <tr><td class="paramname">shouldWaitUntilAvailable</td><td>Indicate if this method should wait for the specified block to become available or return null if it is not immediately available when called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A block record representing the block at the given block index in the format required by the given handler or null if shouldWaitUntilAvailable is set to false and the specified block is unavailable.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a2f24fb69545cb8fd762fd34b11a8d626">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a4762dade87ed9b328ada1634b06dea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4762dade87ed9b328ada1634b06dea9c">&#9670;&nbsp;</a></span>FreeBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sigma.Core.Data.Datasets.Dataset.FreeBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a record block with a certain index associated with the given handler. If all other references to that block index in other formats are freed, the entire block is unloaded (freed) and set to inactive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index to free of the given handler.</td></tr>
    <tr><td class="paramname">handler</td><td>The computation handler the block was originally requested with.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#afce7b78a69002d79c8d5d0f0263220f0">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="ada1a6d8295e0c3b1afdd98583e37283f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1a6d8295e0c3b1afdd98583e37283f">&#9670;&nbsp;</a></span>GetBlockSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Sigma.Core.Data.Datasets.Dataset.GetBlockSizeBytes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (estimated) size of a block in system memory with a certain index and handler format in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the block with the given index and handler format in bytes.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a0a524d9e10e0467c9dcce45d3df877df">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a5af135c5aa3fdff08d4152851af65e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af135c5aa3fdff08d4152851af65e4c">&#9670;&nbsp;</a></span>InvalidateAndClearCaches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sigma.Core.Data.Datasets.Dataset.InvalidateAndClearCaches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate and clear all caches associated with this dataset. WARNING: Removing cache entries may cause certain datasets to load much more slowly or incorrectly. Use cases include removing cache entries for old datasets or datasets with different extractors. </p>

</div>
</div>
<a id="a76510499edcf5a9027111cb3e58814c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76510499edcf5a9027111cb3e58814c1">&#9670;&nbsp;</a></span>IsBlockActive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Data.Datasets.Dataset.IsBlockActive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a certain block index is currently active and loaded in any format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if the given block index is active and loaded.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ac98db8758547d98b709ca5e10f943a52">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a5382d88a756da285a1fd653bf1dbec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5382d88a756da285a1fd653bf1dbec06">&#9670;&nbsp;</a></span>IsBlockActive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Data.Datasets.Dataset.IsBlockActive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a certain block index is currently active and loaded in a certain handler format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index to check.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler of which the format should match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if the given block index is active and loaded in the given handler format.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a49b776b98284e5cdc044ef7c2eef40f2">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a145c28fa1524608dd8dd82a10f5e06d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145c28fa1524608dd8dd82a10f5e06d1">&#9670;&nbsp;</a></span>SplitBlockwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> [] Sigma.Core.Data.Datasets.Dataset.SplitBlockwise </td>
          <td>(</td>
          <td class="paramtype">params int []&#160;</td>
          <td class="paramname"><em>parts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split this dataset block-wise into certain parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parts</td><td>The parts to split into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dataset slices split according to the given parts.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a7fa8ca31044a20347a2b9de0b8f383dd">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="aeedfe54f2561576203e7e025e92f72d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedfe54f2561576203e7e025e92f72d8">&#9670;&nbsp;</a></span>SplitRecordwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> [] Sigma.Core.Data.Datasets.Dataset.SplitRecordwise </td>
          <td>(</td>
          <td class="paramtype">params double []&#160;</td>
          <td class="paramname"><em>percentages</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the dataset record-wise into certain parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">percentages</td><td>The percentages to split into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dataset slices split according to the given percentages (0.0 - x - 1.0).</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a303b0af83085c477e5e3c8cc7b357ec5">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a1042d77af44646d0f0f27bd1ae4a6730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1042d77af44646d0f0f27bd1ae4a6730">&#9670;&nbsp;</a></span>TrySetBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Data.Datasets.Dataset.TrySetBlockSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSizeRecords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to set the block size to a new block size if compatible with the current set block size (e.g. if was auto set and this is the first request). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockSizeRecords</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating whether the block size could be set to the requested block size.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a96f8fd72f2232c1760b94d703b1c5bbc">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abab7e6f6125e590d9f4526095b3ee90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab7e6f6125e590d9f4526095b3ee90e">&#9670;&nbsp;</a></span>BlockSizeAll</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Sigma.Core.Data.Datasets.Dataset.BlockSizeAll = -2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign all available data to the first block (one block fits it all - literally). </p>

</div>
</div>
<a id="a2f28f7ec7eccb136af6c428685c98517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f28f7ec7eccb136af6c428685c98517">&#9670;&nbsp;</a></span>BlockSizeAuto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Sigma.Core.Data.Datasets.Dataset.BlockSizeAuto = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatically size blocks according to estimated data metrics (e.g. physical memory available, record size). </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a62ccb77e43a9a8cd66c66f20303ac694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ccb77e43a9a8cd66c66f20303ac694">&#9670;&nbsp;</a></span>AllowRawReadDataCaching</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Data.Datasets.Dataset.AllowRawReadDataCaching = long.MaxValue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate whether this dataset should cache the raw reader data. If disabled, only extracted data will be cached and once processed, it might be impossible to retrieve preceding record blocks (reader streams are assumed to be non-seekable). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Plainer/Documents/GitHub/Sigma/Sigma.Core/Data/Datasets/Dataset.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
