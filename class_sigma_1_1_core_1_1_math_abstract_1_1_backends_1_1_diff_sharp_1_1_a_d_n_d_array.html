<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sigma: Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="128x128.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sigma
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_sigma.html">Sigma</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core.html">Core</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_math_abstract.html">MathAbstract</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_math_abstract_1_1_backends.html">Backends</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp.html">DiffSharp</a></li><li class="navelem"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">ADNDArray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A default, in-system-memory implementation of the <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html" title="An n-dimensional array of any data type with C-like ordering. Includes utility functions for scalar...">INDArray</a> interface.  
 <a href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.png" usemap="#Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray_3C_20T_20_3E_map" alt=""/>
  <map id="Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray_3C_20T_20_3E_map" name="Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray_3C_20T_20_3E_map">
<area href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html" title="An n-dimensional array of any data type with C-like ordering. Includes utility functions for scalar..." alt="Sigma.Core.MathAbstract.INDArray" shape="rect" coords="194,56,572,80"/>
<area href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html" title="A traceable mathematical object. " alt="Sigma.Core.MathAbstract.ITraceable" shape="rect" coords="0,0,378,24"/>
<area href="interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable.html" title="A deep copyable object. &quot;Deep&quot; means all child references are recursively copied down to actual copya..." alt="Sigma.Core.Utils.IDeepCopyable" shape="rect" coords="388,0,766,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae823f12c34ca4151c3285f85d7b6c0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#aae823f12c34ca4151c3285f85d7b6c0a">ADNDArray</a> (<a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_i_data_buffer.html">IDataBuffer</a>&lt; T &gt; buffer)</td></tr>
<tr class="memdesc:aae823f12c34ca4151c3285f85d7b6c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vectorised ndarray of a certain buffer.  <a href="#aae823f12c34ca4151c3285f85d7b6c0a">More...</a><br /></td></tr>
<tr class="separator:aae823f12c34ca4151c3285f85d7b6c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a1ded03d0bae78d07c8667ef5b7217"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a06a1ded03d0bae78d07c8667ef5b7217">ADNDArray</a> (<a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_i_data_buffer.html">IDataBuffer</a>&lt; T &gt; buffer, long[] shape)</td></tr>
<tr class="memdesc:a06a1ded03d0bae78d07c8667ef5b7217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a ndarray of a certain buffer and shape.  <a href="#a06a1ded03d0bae78d07c8667ef5b7217">More...</a><br /></td></tr>
<tr class="separator:a06a1ded03d0bae78d07c8667ef5b7217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d5e7337b2587fef03fb39852341c4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#ae0d5e7337b2587fef03fb39852341c4b">ADNDArray</a> (T[] data)</td></tr>
<tr class="memdesc:ae0d5e7337b2587fef03fb39852341c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vectorised ndarray of a certain array (array will be COPIED into a data buffer).  <a href="#ae0d5e7337b2587fef03fb39852341c4b">More...</a><br /></td></tr>
<tr class="separator:ae0d5e7337b2587fef03fb39852341c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cc930006c5efdb992db6dc71f86826"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a40cc930006c5efdb992db6dc71f86826">ADNDArray</a> (T[] data, params long[] shape)</td></tr>
<tr class="memdesc:a40cc930006c5efdb992db6dc71f86826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ndarray of a certain array (array will be COPIED into a data buffer) and shape. Total shape length must be smaller or equal than the data array length.  <a href="#a40cc930006c5efdb992db6dc71f86826">More...</a><br /></td></tr>
<tr class="separator:a40cc930006c5efdb992db6dc71f86826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75611fea95a6448b5b12c6f059b861d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a75611fea95a6448b5b12c6f059b861d2">ADNDArray</a> (params long[] shape)</td></tr>
<tr class="memdesc:a75611fea95a6448b5b12c6f059b861d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ndarray of a certain shape (initialised with zeros).  <a href="#a75611fea95a6448b5b12c6f059b861d2">More...</a><br /></td></tr>
<tr class="separator:a75611fea95a6448b5b12c6f059b861d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6993c4c708b91fa1eef8bb49dd8ac30"><td class="memItemLeft" align="right" valign="top">virtual object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#ac6993c4c708b91fa1eef8bb49dd8ac30">DeepCopy</a> ()</td></tr>
<tr class="memdesc:ac6993c4c708b91fa1eef8bb49dd8ac30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy this object.  <a href="#ac6993c4c708b91fa1eef8bb49dd8ac30">More...</a><br /></td></tr>
<tr class="separator:ac6993c4c708b91fa1eef8bb49dd8ac30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfce8d075821cc3b434fb629dd551a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_i_data_buffer.html">IDataBuffer</a>&lt; TOther &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#acbfce8d075821cc3b434fb629dd551a4">GetDataAs&lt; TOther &gt;</a> ()</td></tr>
<tr class="memdesc:acbfce8d075821cc3b434fb629dd551a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a COPY of the underlying data buffer as a certain data type.  <a href="#acbfce8d075821cc3b434fb629dd551a4">More...</a><br /></td></tr>
<tr class="separator:acbfce8d075821cc3b434fb629dd551a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee09cf795a8827fdf0757253f44b1c3"><td class="memItemLeft" align="right" valign="top">TOther&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a5ee09cf795a8827fdf0757253f44b1c3">GetValue&lt; TOther &gt;</a> (params long[] indices)</td></tr>
<tr class="memdesc:a5ee09cf795a8827fdf0757253f44b1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a value at a certain index as a certain type. Note: The value might have to be internally explicitly cast to the requested type (and thereby change).  <a href="#a5ee09cf795a8827fdf0757253f44b1c3">More...</a><br /></td></tr>
<tr class="separator:a5ee09cf795a8827fdf0757253f44b1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041ead10c711130003900e1e5439cb33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a041ead10c711130003900e1e5439cb33">SetValue&lt; TOther &gt;</a> (TOther value, params long[] indices)</td></tr>
<tr class="memdesc:a041ead10c711130003900e1e5439cb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a value of a certain type at a certain index. Note: The value might have to be internally explicitly cast to the internally used type (and thereby change).  <a href="#a041ead10c711130003900e1e5439cb33">More...</a><br /></td></tr>
<tr class="separator:a041ead10c711130003900e1e5439cb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a8d01e6a4535724af52b0b5654391c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a83a8d01e6a4535724af52b0b5654391c">Slice</a> (long[] beginIndices, long[] endIndices)</td></tr>
<tr class="memdesc:a83a8d01e6a4535724af52b0b5654391c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a slice of this ndarray of a certain region as a new ndarray with the same underlying data.  <a href="#a83a8d01e6a4535724af52b0b5654391c">More...</a><br /></td></tr>
<tr class="separator:a83a8d01e6a4535724af52b0b5654391c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4ec1d9c85581cd59b909aa29fe987e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a9f4ec1d9c85581cd59b909aa29fe987e">Flatten</a> ()</td></tr>
<tr class="memdesc:a9f4ec1d9c85581cd59b909aa29fe987e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a NEW flattened ndarray with the same data but a flat shape (row vector).  <a href="#a9f4ec1d9c85581cd59b909aa29fe987e">More...</a><br /></td></tr>
<tr class="separator:a9f4ec1d9c85581cd59b909aa29fe987e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14203f458479cf932d4f50c0754d98d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a14203f458479cf932d4f50c0754d98d6">FlattenSelf</a> ()</td></tr>
<tr class="memdesc:a14203f458479cf932d4f50c0754d98d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten THIS ndarray to a flat row vector.  <a href="#a14203f458479cf932d4f50c0754d98d6">More...</a><br /></td></tr>
<tr class="separator:a14203f458479cf932d4f50c0754d98d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4d39a955a0e85467877ac29c1ec32d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a2d4d39a955a0e85467877ac29c1ec32d">Reshape</a> (params long[] newShape)</td></tr>
<tr class="memdesc:a2d4d39a955a0e85467877ac29c1ec32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a NEW ndarray with the same data but another shape (and different strides). Note: The total length of the ndarray cannot change.  <a href="#a2d4d39a955a0e85467877ac29c1ec32d">More...</a><br /></td></tr>
<tr class="separator:a2d4d39a955a0e85467877ac29c1ec32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f4052dd979755b444fde997d9866b9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#af1f4052dd979755b444fde997d9866b9">ReshapeSelf</a> (params long[] newShape)</td></tr>
<tr class="memdesc:af1f4052dd979755b444fde997d9866b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape THIS ndarray to a new shape (this operation also changes strides). Note: The total length of the ndarray cannot change.  <a href="#af1f4052dd979755b444fde997d9866b9">More...</a><br /></td></tr>
<tr class="separator:af1f4052dd979755b444fde997d9866b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5b0f22e1821e91b7775d38a79517a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#ada5b0f22e1821e91b7775d38a79517a3">Permute</a> (params int[] rearrangedDimensions)</td></tr>
<tr class="memdesc:ada5b0f22e1821e91b7775d38a79517a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a NEW ndarray with the same data but another permuted shape (and also different strides). Permutation occurs according to the content of the rearranged dimensions array, where each element represents the number of a dimension to swap with. The permutation array has to have the same number of dimensions as the actual shape.  <a href="#ada5b0f22e1821e91b7775d38a79517a3">More...</a><br /></td></tr>
<tr class="separator:ada5b0f22e1821e91b7775d38a79517a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bafb14bcad33f63a68aa83e4a3bcf1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a72bafb14bcad33f63a68aa83e4a3bcf1">PermuteSelf</a> (params int[] rearrangedDimensions)</td></tr>
<tr class="memdesc:a72bafb14bcad33f63a68aa83e4a3bcf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute THIS ndarray to another permuted shape (and also different strides). Permutation occurs according to the content of the rearranged dimensions array, where each element represents the number of a dimension to swap with. The permutation array has to have the same number of dimensions as the actual shape.  <a href="#a72bafb14bcad33f63a68aa83e4a3bcf1">More...</a><br /></td></tr>
<tr class="separator:a72bafb14bcad33f63a68aa83e4a3bcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99af18400583b1eec6e0fc9221e68d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a99af18400583b1eec6e0fc9221e68d72">Transpose</a> ()</td></tr>
<tr class="memdesc:a99af18400583b1eec6e0fc9221e68d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a NEW ndarray with the same data but transposed (reversed dimensions).  <a href="#a99af18400583b1eec6e0fc9221e68d72">More...</a><br /></td></tr>
<tr class="separator:a99af18400583b1eec6e0fc9221e68d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188c7d115692d434a3e102d12b7e70d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a188c7d115692d434a3e102d12b7e70d0">TransposeSelf</a> ()</td></tr>
<tr class="memdesc:a188c7d115692d434a3e102d12b7e70d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose THIS ndarray (reverse dimensions).  <a href="#a188c7d115692d434a3e102d12b7e70d0">More...</a><br /></td></tr>
<tr class="separator:a188c7d115692d434a3e102d12b7e70d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385d8b928ba387714f6c572d3753c143"><td class="memItemLeft" align="right" valign="top"><a id="a385d8b928ba387714f6c572d3753c143"></a>
override string&#160;</td><td class="memItemRight" valign="bottom"><b>ToString</b> ()</td></tr>
<tr class="separator:a385d8b928ba387714f6c572d3753c143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa012631e745bec29d09cc227b2a994ae"><td class="memItemLeft" align="right" valign="top"><a id="aa012631e745bec29d09cc227b2a994ae"></a>
delegate string&#160;</td><td class="memItemRight" valign="bottom"><b>ToStringElement</b> (T element)</td></tr>
<tr class="separator:aa012631e745bec29d09cc227b2a994ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f417b994cd4c9d688c0caaf9527e7f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html#a76f417b994cd4c9d688c0caaf9527e7f">ToString</a> (ToStringElement toStringElement, int dimensionNewLine=1, bool printSeperator=true)</td></tr>
<tr class="memdesc:a76f417b994cd4c9d688c0caaf9527e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a string representing the contents of this ndarray, formatted properly and somewhat customisable.  <a href="#a76f417b994cd4c9d688c0caaf9527e7f">More...</a><br /></td></tr>
<tr class="separator:a76f417b994cd4c9d688c0caaf9527e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a203e0575d1ec451901f03f05b195b9ed"><td class="memItemLeft" align="right" valign="top"><a id="a203e0575d1ec451901f03f05b195b9ed"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Reinitialise</b> (long[] shape, long[] strides)</td></tr>
<tr class="separator:a203e0575d1ec451901f03f05b195b9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268412635e6287e11b99428a92300b32"><td class="memItemLeft" align="right" valign="top"><a id="a268412635e6287e11b99428a92300b32"></a>
long []&#160;</td><td class="memItemRight" valign="bottom"><b>GetSlicedShape</b> (long[] beginIndices, long[] endIndices)</td></tr>
<tr class="separator:a268412635e6287e11b99428a92300b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:af3df2bbb56af12b36e0912b981ab0400"><td class="memItemLeft" align="right" valign="top"><a id="af3df2bbb56af12b36e0912b981ab0400"></a>
<a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AssociatedHandler</b><code> [get, set]</code></td></tr>
<tr class="separator:af3df2bbb56af12b36e0912b981ab0400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6e091266a360c19314df54a7fd2f93"><td class="memItemLeft" align="right" valign="top"><a id="a4a6e091266a360c19314df54a7fd2f93"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>Length</b><code> [get, private set]</code></td></tr>
<tr class="separator:a4a6e091266a360c19314df54a7fd2f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0735a55f6c1466a7c9810a99edd5a294"><td class="memItemLeft" align="right" valign="top"><a id="a0735a55f6c1466a7c9810a99edd5a294"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Rank</b><code> [get, private set]</code></td></tr>
<tr class="separator:a0735a55f6c1466a7c9810a99edd5a294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc35a14897e66851be869e1447539c42"><td class="memItemLeft" align="right" valign="top"><a id="adc35a14897e66851be869e1447539c42"></a>
long []&#160;</td><td class="memItemRight" valign="bottom"><b>Shape</b><code> [get, private set]</code></td></tr>
<tr class="separator:adc35a14897e66851be869e1447539c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77497b99cee09c3990dc4c3ee8f03bb7"><td class="memItemLeft" align="right" valign="top"><a id="a77497b99cee09c3990dc4c3ee8f03bb7"></a>
long []&#160;</td><td class="memItemRight" valign="bottom"><b>Strides</b><code> [get, private set]</code></td></tr>
<tr class="separator:a77497b99cee09c3990dc4c3ee8f03bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a8ba75914df61660fa41697139173e"><td class="memItemLeft" align="right" valign="top"><a id="ad3a8ba75914df61660fa41697139173e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScalar</b><code> [get, private set]</code></td></tr>
<tr class="separator:ad3a8ba75914df61660fa41697139173e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c237b989bc843895fa2a5cc22af270"><td class="memItemLeft" align="right" valign="top"><a id="a68c237b989bc843895fa2a5cc22af270"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVector</b><code> [get, private set]</code></td></tr>
<tr class="separator:a68c237b989bc843895fa2a5cc22af270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a4ce8a5c5723eab6363392a60fd8b5"><td class="memItemLeft" align="right" valign="top"><a id="a33a4ce8a5c5723eab6363392a60fd8b5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsMatrix</b><code> [get, private set]</code></td></tr>
<tr class="separator:a33a4ce8a5c5723eab6363392a60fd8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">Sigma.Core.MathAbstract.INDArray</a></td></tr>
<tr class="memitem:ac2f79ed481caeac8e89285c8628521af inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#ac2f79ed481caeac8e89285c8628521af">Rank</a><code> [get]</code></td></tr>
<tr class="memdesc:ac2f79ed481caeac8e89285c8628521af inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank of this ndarray (number of dimensions).  <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#ac2f79ed481caeac8e89285c8628521af">More...</a><br /></td></tr>
<tr class="separator:ac2f79ed481caeac8e89285c8628521af inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b156ef66492a0054a48dd7609f8a4f7 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a2b156ef66492a0054a48dd7609f8a4f7">Length</a><code> [get]</code></td></tr>
<tr class="memdesc:a2b156ef66492a0054a48dd7609f8a4f7 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of this ndarray (total number of elements).  <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a2b156ef66492a0054a48dd7609f8a4f7">More...</a><br /></td></tr>
<tr class="separator:a2b156ef66492a0054a48dd7609f8a4f7 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af509c6a88045887f085da4a4a73f2c60 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memItemLeft" align="right" valign="top">long []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#af509c6a88045887f085da4a4a73f2c60">Shape</a><code> [get]</code></td></tr>
<tr class="memdesc:af509c6a88045887f085da4a4a73f2c60 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shape of this ndarray (i.e. the dimensions).  <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#af509c6a88045887f085da4a4a73f2c60">More...</a><br /></td></tr>
<tr class="separator:af509c6a88045887f085da4a4a73f2c60 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13cd0073779c6083843e1d69b031605 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memItemLeft" align="right" valign="top">long []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#ab13cd0073779c6083843e1d69b031605">Strides</a><code> [get]</code></td></tr>
<tr class="memdesc:ab13cd0073779c6083843e1d69b031605 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strides of this ndarray. A stride at any dimension defines how many elements to skip to move to the next element along that dimension.  <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#ab13cd0073779c6083843e1d69b031605">More...</a><br /></td></tr>
<tr class="separator:ab13cd0073779c6083843e1d69b031605 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcae99a669db63943952a3b510746df inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a2dcae99a669db63943952a3b510746df">IsScalar</a><code> [get]</code></td></tr>
<tr class="memdesc:a2dcae99a669db63943952a3b510746df inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience flag indicating if this ndarray is a scalar (i.e. if its shape is {1})  <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a2dcae99a669db63943952a3b510746df">More...</a><br /></td></tr>
<tr class="separator:a2dcae99a669db63943952a3b510746df inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42319c4b5ed047c8de183405d7c7f7c inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#aa42319c4b5ed047c8de183405d7c7f7c">IsVector</a><code> [get]</code></td></tr>
<tr class="memdesc:aa42319c4b5ed047c8de183405d7c7f7c inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience flag indicating if this ndarray is a vector (i.e. if its shape is 1-dimensional)  <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#aa42319c4b5ed047c8de183405d7c7f7c">More...</a><br /></td></tr>
<tr class="separator:aa42319c4b5ed047c8de183405d7c7f7c inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92feaa5c25202385ef35b6c671aed207 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a92feaa5c25202385ef35b6c671aed207">IsMatrix</a><code> [get]</code></td></tr>
<tr class="memdesc:a92feaa5c25202385ef35b6c671aed207 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience flag indicating if this ndarray is a matrix (i.e. if its shape is 2-dimensional)  <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a92feaa5c25202385ef35b6c671aed207">More...</a><br /></td></tr>
<tr class="separator:a92feaa5c25202385ef35b6c671aed207 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html">Sigma.Core.MathAbstract.ITraceable</a></td></tr>
<tr class="memitem:ae84f817a09e9205af9fa0e11f5d973b5 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html#ae84f817a09e9205af9fa0e11f5d973b5">AssociatedHandler</a><code> [get]</code></td></tr>
<tr class="memdesc:ae84f817a09e9205af9fa0e11f5d973b5 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computation handler associated with this traceable object (null if none).  <a href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable.html#ae84f817a09e9205af9fa0e11f5d973b5">More...</a><br /></td></tr>
<tr class="separator:ae84f817a09e9205af9fa0e11f5d973b5 inherit properties_interface_sigma_1_1_core_1_1_math_abstract_1_1_i_traceable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a69864aa44868d9d310264be975d72383"><td class="memItemLeft" align="right" valign="top"><a id="a69864aa44868d9d310264be975d72383"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Initialise</b> (long[] shape, long[] strides)</td></tr>
<tr class="separator:a69864aa44868d9d310264be975d72383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36794fb2f5df3eda0e0464f9f33dbf7"><td class="memItemLeft" align="right" valign="top"><a id="ab36794fb2f5df3eda0e0464f9f33dbf7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckRearrangedDimensions</b> (int[] rearrangedDimensions)</td></tr>
<tr class="separator:ab36794fb2f5df3eda0e0464f9f33dbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a828b0938a4fea796eff2bf9141943e7f"><td class="memItemLeft" align="right" valign="top"><a id="a828b0938a4fea796eff2bf9141943e7f"></a>
<a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_associatedHandler</b></td></tr>
<tr class="separator:a828b0938a4fea796eff2bf9141943e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A default, in-system-memory implementation of the <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html" title="An n-dimensional array of any data type with C-like ordering. Includes utility functions for scalar...">INDArray</a> interface. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of this ndarray.</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aae823f12c34ca4151c3285f85d7b6c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae823f12c34ca4151c3285f85d7b6c0a">&#9670;&nbsp;</a></span>ADNDArray() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.<a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">ADNDArray</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_i_data_buffer.html">IDataBuffer</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vectorised ndarray of a certain buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to back this ndarray.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06a1ded03d0bae78d07c8667ef5b7217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a1ded03d0bae78d07c8667ef5b7217">&#9670;&nbsp;</a></span>ADNDArray() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.<a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">ADNDArray</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_i_data_buffer.html">IDataBuffer</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long []&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a ndarray of a certain buffer and shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to back this ndarray.</td></tr>
    <tr><td class="paramname">shape</td><td>The shape.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0d5e7337b2587fef03fb39852341c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d5e7337b2587fef03fb39852341c4b">&#9670;&nbsp;</a></span>ADNDArray() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.<a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">ADNDArray</a> </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vectorised ndarray of a certain array (array will be COPIED into a data buffer). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to use to fill this ndarray.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40cc930006c5efdb992db6dc71f86826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cc930006c5efdb992db6dc71f86826">&#9670;&nbsp;</a></span>ADNDArray() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.<a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">ADNDArray</a> </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ndarray of a certain array (array will be COPIED into a data buffer) and shape. Total shape length must be smaller or equal than the data array length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to use to fill this ndarray.</td></tr>
    <tr><td class="paramname">shape</td><td>The shape.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75611fea95a6448b5b12c6f059b861d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75611fea95a6448b5b12c6f059b861d2">&#9670;&nbsp;</a></span>ADNDArray() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.<a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">ADNDArray</a> </td>
          <td>(</td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ndarray of a certain shape (initialised with zeros). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac6993c4c708b91fa1eef8bb49dd8ac30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6993c4c708b91fa1eef8bb49dd8ac30">&#9670;&nbsp;</a></span>DeepCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual object <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.DeepCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy this object. </p>
<dl class="section return"><dt>Returns</dt><dd>A deep copy of this object.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_utils_1_1_i_deep_copyable.html#ab066dde4b00126e9c9b39764887b22b1">Sigma.Core.Utils.IDeepCopyable</a>.</p>

<p>Reimplemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_native_cpu_1_1_a_d_n_d_float32_array.html#a7ba163c2c8d7089c70365a269613ef24">Sigma.Core.MathAbstract.Backends.DiffSharp.NativeCpu.ADNDFloat32Array</a>.</p>

</div>
</div>
<a id="a9f4ec1d9c85581cd59b909aa29fe987e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4ec1d9c85581cd59b909aa29fe987e">&#9670;&nbsp;</a></span>Flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.Flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a NEW flattened ndarray with the same data but a flat shape (row vector). </p>
<dl class="section return"><dt>Returns</dt><dd>A NEW flattened ndarray with the same data.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a74af7dbdbf9453beedefa2d6d5fd6375">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<a id="a14203f458479cf932d4f50c0754d98d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14203f458479cf932d4f50c0754d98d6">&#9670;&nbsp;</a></span>FlattenSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.FlattenSelf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten THIS ndarray to a flat row vector. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a6b4426b31633f4d8b46cfe8af864a8e6">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<a id="acbfce8d075821cc3b434fb629dd551a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfce8d075821cc3b434fb629dd551a4">&#9670;&nbsp;</a></span>GetDataAs< TOther >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_i_data_buffer.html">IDataBuffer</a>&lt;TOther&gt; <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.GetDataAs&lt; TOther &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a COPY of the underlying data buffer as a certain data type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOther</td><td>The type the buffer should have.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data buffer with the given data type.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a11f923a488660b89ad4cbf910a39f42c">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<a id="a5ee09cf795a8827fdf0757253f44b1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee09cf795a8827fdf0757253f44b1c3">&#9670;&nbsp;</a></span>GetValue< TOther >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TOther <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.GetValue&lt; TOther &gt; </td>
          <td>(</td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a value at a certain index as a certain type. Note: The value might have to be internally explicitly cast to the requested type (and thereby change). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOther</td><td>The type the value should have.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the given index as the given type.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a9aed17ce39ec790b3bad7e146f042903">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<a id="ada5b0f22e1821e91b7775d38a79517a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5b0f22e1821e91b7775d38a79517a3">&#9670;&nbsp;</a></span>Permute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.Permute </td>
          <td>(</td>
          <td class="paramtype">params int []&#160;</td>
          <td class="paramname"><em>rearrangedDimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a NEW ndarray with the same data but another permuted shape (and also different strides). Permutation occurs according to the content of the rearranged dimensions array, where each element represents the number of a dimension to swap with. The permutation array has to have the same number of dimensions as the actual shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rearrangedDimensions</td><td>The dimensions to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NEW ndarray with the same data and a new permuted shape.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#acd26fddf232c4c1d3d6459f14fafcddb">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<a id="a72bafb14bcad33f63a68aa83e4a3bcf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bafb14bcad33f63a68aa83e4a3bcf1">&#9670;&nbsp;</a></span>PermuteSelf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.PermuteSelf </td>
          <td>(</td>
          <td class="paramtype">params int []&#160;</td>
          <td class="paramname"><em>rearrangedDimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute THIS ndarray to another permuted shape (and also different strides). Permutation occurs according to the content of the rearranged dimensions array, where each element represents the number of a dimension to swap with. The permutation array has to have the same number of dimensions as the actual shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rearrangedDimensions</td><td>The dimensions to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This ndarray (for convenience).</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a1d870bf4c4a940eaebb6b1edf8c60558">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<a id="a2d4d39a955a0e85467877ac29c1ec32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4d39a955a0e85467877ac29c1ec32d">&#9670;&nbsp;</a></span>Reshape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.Reshape </td>
          <td>(</td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>newShape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a NEW ndarray with the same data but another shape (and different strides). Note: The total length of the ndarray cannot change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newShape</td><td>The new shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NEW ndarray with the same data and the given shape.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a811f9ab94bae55a882fef7f2f2462fca">Sigma.Core.MathAbstract.INDArray</a>.</p>

<p>Reimplemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_native_cpu_1_1_a_d_n_d_float32_array.html#a614e008fe04029e74045223e694e6577">Sigma.Core.MathAbstract.Backends.DiffSharp.NativeCpu.ADNDFloat32Array</a>.</p>

</div>
</div>
<a id="af1f4052dd979755b444fde997d9866b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f4052dd979755b444fde997d9866b9">&#9670;&nbsp;</a></span>ReshapeSelf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.ReshapeSelf </td>
          <td>(</td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>newShape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape THIS ndarray to a new shape (this operation also changes strides). Note: The total length of the ndarray cannot change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newShape</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This ndarray (for convenience).</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#aa0d8cdce99b5d58221dbb71bd06c5ae0">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<a id="a041ead10c711130003900e1e5439cb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041ead10c711130003900e1e5439cb33">&#9670;&nbsp;</a></span>SetValue< TOther >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.SetValue&lt; TOther &gt; </td>
          <td>(</td>
          <td class="paramtype">TOther&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params long []&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a value of a certain type at a certain index. Note: The value might have to be internally explicitly cast to the internally used type (and thereby change). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOther</td><td>The type of the given value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value.</td></tr>
    <tr><td class="paramname">indices</td><td>The indices.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a7ff221e48e75e5de20c6cae58a59cf0f">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<a id="a83a8d01e6a4535724af52b0b5654391c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a8d01e6a4535724af52b0b5654391c">&#9670;&nbsp;</a></span>Slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.Slice </td>
          <td>(</td>
          <td class="paramtype">long []&#160;</td>
          <td class="paramname"><em>beginIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long []&#160;</td>
          <td class="paramname"><em>endIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a slice of this ndarray of a certain region as a new ndarray with the same underlying data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginIndices</td><td>The begin indices (inclusively, where the slice should begin).</td></tr>
    <tr><td class="paramname">endIndices</td><td>The end indices (exclusively, where the slice should end).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a89d893a6ca95de9a04cbd2972391af3a">Sigma.Core.MathAbstract.INDArray</a>.</p>

<p>Reimplemented in <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_native_cpu_1_1_a_d_n_d_float32_array.html#ab96a4957af2af1e2a08297d410f6c142">Sigma.Core.MathAbstract.Backends.DiffSharp.NativeCpu.ADNDFloat32Array</a>.</p>

</div>
</div>
<a id="a76f417b994cd4c9d688c0caaf9527e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f417b994cd4c9d688c0caaf9527e7f">&#9670;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.ToString </td>
          <td>(</td>
          <td class="paramtype">ToStringElement&#160;</td>
          <td class="paramname"><em>toStringElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensionNewLine</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>printSeperator</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a string representing the contents of this ndarray, formatted properly and somewhat customisable. </p>
<dl class="section return"><dt>Returns</dt><dd>A fancy string representing the contents of this ndarray.</dd></dl>

</div>
</div>
<a id="a99af18400583b1eec6e0fc9221e68d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99af18400583b1eec6e0fc9221e68d72">&#9670;&nbsp;</a></span>Transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.Transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a NEW ndarray with the same data but transposed (reversed dimensions). </p>
<dl class="section return"><dt>Returns</dt><dd>A NEW ndarray with the same data but transposed (reversed dimensions).</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a34bd3d64fde5e14da25c90cac2e0a588">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<a id="a188c7d115692d434a3e102d12b7e70d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188c7d115692d434a3e102d12b7e70d0">&#9670;&nbsp;</a></span>TransposeSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> <a class="el" href="class_sigma_1_1_core_1_1_math_abstract_1_1_backends_1_1_diff_sharp_1_1_a_d_n_d_array.html">Sigma.Core.MathAbstract.Backends.DiffSharp.ADNDArray</a>&lt; T &gt;.TransposeSelf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose THIS ndarray (reverse dimensions). </p>
<dl class="section return"><dt>Returns</dt><dd>This ndarray (for convenience).</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html#a7a91147f2ab41c01e4c33d0d9213d7b9">Sigma.Core.MathAbstract.INDArray</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Plainer/Documents/GitHub/Sigma/Sigma.Core/MathAbstract/Backends/DiffSharp/ADNDArray.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
