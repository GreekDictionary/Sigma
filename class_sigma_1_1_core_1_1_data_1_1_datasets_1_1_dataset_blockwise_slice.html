<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sigma: Sigma.Core.Data.Datasets.DatasetBlockwiseSlice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="128x128.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sigma
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_sigma.html">Sigma</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core.html">Core</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_data.html">Data</a></li><li class="navelem"><a class="el" href="namespace_sigma_1_1_core_1_1_data_1_1_datasets.html">Datasets</a></li><li class="navelem"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html">DatasetBlockwiseSlice</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sigma.Core.Data.Datasets.DatasetBlockwiseSlice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A dataset slice representing a part of an underlying dataset. Block-wise datasets forward some blocks per block, i.e. some entire blocks per slice instead of some parts of each block (as in <a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_recordwise_slice.html" title="A dataset slice representing a part of an underlying dataset. Record-wise datasets forward partial bl...">DatasetRecordwiseSlice</a>.  
 <a href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Sigma.Core.Data.Datasets.DatasetBlockwiseSlice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.png" usemap="#Sigma.Core.Data.Datasets.DatasetBlockwiseSlice_map" alt=""/>
  <map id="Sigma.Core.Data.Datasets.DatasetBlockwiseSlice_map" name="Sigma.Core.Data.Datasets.DatasetBlockwiseSlice_map">
<area href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html" title="A dataset representing a collection of record blocks, where blocks can be " alt="Sigma.Core.Data.Datasets.IDataset" shape="rect" coords="0,56,290,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a36daf5dad56f60e45007b14dc7a052b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#a36daf5dad56f60e45007b14dc7a052b1">DatasetBlockwiseSlice</a> (<a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> underlyingDataset, int splitBeginIndex, int splitEndIndex, int splitInterval)</td></tr>
<tr class="memdesc:a36daf5dad56f60e45007b14dc7a052b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block-wise slice dataset of an underlying dataset with a certain split. A block-wise split example: In order to assign a slice of 1 out of 5 blocks to this dataset, the split begin index would be 0, split end index 1 and split interval 5. Or split begin of 1 and end of 2, begin of 2 and end of 3, begin of 3 and end of 4, depending on the order in which this slice should take blocks.  <a href="#a36daf5dad56f60e45007b14dc7a052b1">More...</a><br /></td></tr>
<tr class="separator:a36daf5dad56f60e45007b14dc7a052b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f6d5f57e4f1410a60cd23d419938d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#a84f6d5f57e4f1410a60cd23d419938d4">SplitBlockwise</a> (params int[] parts)</td></tr>
<tr class="memdesc:a84f6d5f57e4f1410a60cd23d419938d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split this dataset block-wise into certain parts.  <a href="#a84f6d5f57e4f1410a60cd23d419938d4">More...</a><br /></td></tr>
<tr class="separator:a84f6d5f57e4f1410a60cd23d419938d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41796ad5214dfcad90f4236f82b711b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#a41796ad5214dfcad90f4236f82b711b8">SplitRecordwise</a> (params double[] parts)</td></tr>
<tr class="memdesc:a41796ad5214dfcad90f4236f82b711b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the dataset record-wise into certain parts.  <a href="#a41796ad5214dfcad90f4236f82b711b8">More...</a><br /></td></tr>
<tr class="separator:a41796ad5214dfcad90f4236f82b711b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e61b88a80aa9ecbe9e4ba7c57b8ee6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#a7e61b88a80aa9ecbe9e4ba7c57b8ee6a">TrySetBlockSize</a> (int blockSizeRecords)</td></tr>
<tr class="memdesc:a7e61b88a80aa9ecbe9e4ba7c57b8ee6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to set the block size to a new block size if compatible with the current set block size (e.g. if was auto set and this is the first request).  <a href="#a7e61b88a80aa9ecbe9e4ba7c57b8ee6a">More...</a><br /></td></tr>
<tr class="separator:a7e61b88a80aa9ecbe9e4ba7c57b8ee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48e4777532999abded68501cf5c571e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#ac48e4777532999abded68501cf5c571e">IsBlockActive</a> (int blockIndex)</td></tr>
<tr class="memdesc:ac48e4777532999abded68501cf5c571e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a certain block index is currently active and loaded in any format.  <a href="#ac48e4777532999abded68501cf5c571e">More...</a><br /></td></tr>
<tr class="separator:ac48e4777532999abded68501cf5c571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0f27cf6c5ce149ac8deed62af616bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#a4a0f27cf6c5ce149ac8deed62af616bf">IsBlockActive</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:a4a0f27cf6c5ce149ac8deed62af616bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a certain block index is currently active and loaded in a certain handler format.  <a href="#a4a0f27cf6c5ce149ac8deed62af616bf">More...</a><br /></td></tr>
<tr class="separator:a4a0f27cf6c5ce149ac8deed62af616bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac349c0480289155d88619b3562a4d7f7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#ac349c0480289155d88619b3562a4d7f7">GetBlockSizeBytes</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:ac349c0480289155d88619b3562a4d7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (estimated) size of a block in system memory with a certain index and handler format in bytes.  <a href="#ac349c0480289155d88619b3562a4d7f7">More...</a><br /></td></tr>
<tr class="separator:ac349c0480289155d88619b3562a4d7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5b9e5acc5aafc12936a829e61be5b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#acb5b9e5acc5aafc12936a829e61be5b4">CanFetchBlocksAfter</a> (int blockIndex)</td></tr>
<tr class="memdesc:acb5b9e5acc5aafc12936a829e61be5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether any more blocks can be fetched after a specified block index.  <a href="#acb5b9e5acc5aafc12936a829e61be5b4">More...</a><br /></td></tr>
<tr class="separator:acb5b9e5acc5aafc12936a829e61be5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b61f4befcdbc58ffc0a18bcfe821bf"><td class="memItemLeft" align="right" valign="top">IDictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#a32b61f4befcdbc58ffc0a18bcfe821bf">FetchBlock</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler, bool shouldWaitUntilAvailable=true)</td></tr>
<tr class="memdesc:a32b61f4befcdbc58ffc0a18bcfe821bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch named record block with a certain index for a certain computation handler. Load, prepare and convert the requested block to the format required by a certain handler unless it was already fetched and is still active in that format. If the specified block can currently not be loaded due to memory constraints (as specified in MaxConcurrentActiveBlocks and MaxTotalActiveBlockSizeBytes):  <a href="#a32b61f4befcdbc58ffc0a18bcfe821bf">More...</a><br /></td></tr>
<tr class="separator:a32b61f4befcdbc58ffc0a18bcfe821bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdec85300e33c8211c17cabc35d3b567"><td class="memItemLeft" align="right" valign="top">Task&lt; IDictionary&lt; string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#afdec85300e33c8211c17cabc35d3b567">FetchBlockAsync</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler, bool shouldWaitUntilAvailable=true)</td></tr>
<tr class="memdesc:afdec85300e33c8211c17cabc35d3b567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a record block with a certain index for a certain computation handler asynchronously. Load, prepare and convert the requested block to the format required by a certain handler unless it was already fetched and is still active in that format. If the specified block can currently not be loaded due to memory constraints (as specified in MaxConcurrentActiveBlocks and MaxTotalActiveBlockSizeBytes):  <a href="#afdec85300e33c8211c17cabc35d3b567">More...</a><br /></td></tr>
<tr class="separator:afdec85300e33c8211c17cabc35d3b567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb864eb51984dc88e66fa6dff997c2a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#aeb864eb51984dc88e66fa6dff997c2a1">FreeBlock</a> (int blockIndex, <a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a> handler)</td></tr>
<tr class="memdesc:aeb864eb51984dc88e66fa6dff997c2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a record block with a certain index associated with the given handler. If all other references to that block index in other formats are freed, the entire block is unloaded (freed) and set to inactive.  <a href="#aeb864eb51984dc88e66fa6dff997c2a1">More...</a><br /></td></tr>
<tr class="separator:aeb864eb51984dc88e66fa6dff997c2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384336b8f9691d033a7c239ef29eb3ad"><td class="memItemLeft" align="right" valign="top"><a id="a384336b8f9691d033a7c239ef29eb3ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Dispose</b> ()</td></tr>
<tr class="separator:a384336b8f9691d033a7c239ef29eb3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aecaab7d443162f1b038a63147548fc94"><td class="memItemLeft" align="right" valign="top"><a id="aecaab7d443162f1b038a63147548fc94"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>Name</b> =&gt; UnderlyingDataset.Name</td></tr>
<tr class="separator:aecaab7d443162f1b038a63147548fc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eb659b7257e6f3960088b1c160988e"><td class="memItemLeft" align="right" valign="top"><a id="a21eb659b7257e6f3960088b1c160988e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TargetBlockSizeRecords</b> =&gt; UnderlyingDataset.TargetBlockSizeRecords</td></tr>
<tr class="separator:a21eb659b7257e6f3960088b1c160988e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d9755107d01949e9df2ad63fa683bd"><td class="memItemLeft" align="right" valign="top"><a id="a40d9755107d01949e9df2ad63fa683bd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxConcurrentActiveBlocks</b> =&gt; UnderlyingDataset.MaxConcurrentActiveBlocks</td></tr>
<tr class="separator:a40d9755107d01949e9df2ad63fa683bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e53590af460a86b6d8eb1f92550da4"><td class="memItemLeft" align="right" valign="top"><a id="a80e53590af460a86b6d8eb1f92550da4"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>MaxTotalActiveBlockSizeBytes</b> =&gt; UnderlyingDataset.MaxTotalActiveBlockSizeBytes</td></tr>
<tr class="separator:a80e53590af460a86b6d8eb1f92550da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1884eb52bdae0c9b51b6b30ba4a6d135"><td class="memItemLeft" align="right" valign="top"><a id="a1884eb52bdae0c9b51b6b30ba4a6d135"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>TotalActiveBlockSizeBytes</b> =&gt; UnderlyingDataset.TotalActiveBlockSizeBytes</td></tr>
<tr class="separator:a1884eb52bdae0c9b51b6b30ba4a6d135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60328e9e1bea61087230d63ecb867667"><td class="memItemLeft" align="right" valign="top"><a id="a60328e9e1bea61087230d63ecb867667"></a>
string []&#160;</td><td class="memItemRight" valign="bottom"><b>SectionNames</b> =&gt; UnderlyingDataset.SectionNames</td></tr>
<tr class="separator:a60328e9e1bea61087230d63ecb867667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22b980e7068963b17ec6a2b85d8ff82"><td class="memItemLeft" align="right" valign="top"><a id="aa22b980e7068963b17ec6a2b85d8ff82"></a>
IReadOnlyCollection&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ActiveBlockIndices</b> =&gt; UnderlyingDataset.ActiveBlockIndices</td></tr>
<tr class="separator:aa22b980e7068963b17ec6a2b85d8ff82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fc3e122910542af01bee18d14eb7e9"><td class="memItemLeft" align="right" valign="top"><a id="a86fc3e122910542af01bee18d14eb7e9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ActiveIndividualBlockCount</b> =&gt; UnderlyingDataset.ActiveIndividualBlockCount</td></tr>
<tr class="separator:a86fc3e122910542af01bee18d14eb7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9a2e7df6b51b7d25d36e774ced55e6"><td class="memItemLeft" align="right" valign="top"><a id="afd9a2e7df6b51b7d25d36e774ced55e6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ActiveBlockRegionCount</b> =&gt; UnderlyingDataset.ActiveBlockRegionCount</td></tr>
<tr class="separator:afd9a2e7df6b51b7d25d36e774ced55e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0e1f28f5fef143245e8a7dfa3550a572"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_blockwise_slice.html#a0e1f28f5fef143245e8a7dfa3550a572">MapToUnderlyingIndex</a> (int blockIndex)</td></tr>
<tr class="memdesc:a0e1f28f5fef143245e8a7dfa3550a572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an index relative to this dataset slice to an index relative to the underlying dataset.  <a href="#a0e1f28f5fef143245e8a7dfa3550a572">More...</a><br /></td></tr>
<tr class="separator:a0e1f28f5fef143245e8a7dfa3550a572"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ad20fae33d4920c6b3d543ffe1c2f5789"><td class="memItemLeft" align="right" valign="top"><a id="ad20fae33d4920c6b3d543ffe1c2f5789"></a>
<a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a>&#160;</td><td class="memItemRight" valign="bottom"><b>UnderlyingDataset</b><code> [get]</code></td></tr>
<tr class="separator:ad20fae33d4920c6b3d543ffe1c2f5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b345c890d3ad33be41e27ea0886a96"><td class="memItemLeft" align="right" valign="top"><a id="ab6b345c890d3ad33be41e27ea0886a96"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SplitBeginIndex</b><code> [get]</code></td></tr>
<tr class="separator:ab6b345c890d3ad33be41e27ea0886a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bef5375d16d170b1c413ae5c2a4616"><td class="memItemLeft" align="right" valign="top"><a id="af7bef5375d16d170b1c413ae5c2a4616"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SplitEndIndex</b><code> [get]</code></td></tr>
<tr class="separator:af7bef5375d16d170b1c413ae5c2a4616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b8a32e27e0f9b771cdae3751fa602a"><td class="memItemLeft" align="right" valign="top"><a id="aa6b8a32e27e0f9b771cdae3751fa602a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SplitSize</b><code> [get]</code></td></tr>
<tr class="separator:aa6b8a32e27e0f9b771cdae3751fa602a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263b4223777160378651feb8de9ace76"><td class="memItemLeft" align="right" valign="top"><a id="a263b4223777160378651feb8de9ace76"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SplitInterval</b><code> [get]</code></td></tr>
<tr class="separator:a263b4223777160378651feb8de9ace76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa218a4b491c4fa4d87adfb776b494f"><td class="memItemLeft" align="right" valign="top"><a id="a2fa218a4b491c4fa4d87adfb776b494f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxBlocksInCache</b><code> [get, set]</code></td></tr>
<tr class="separator:a2fa218a4b491c4fa4d87adfb776b494f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0a7e723c0e4e0225f3cabbc0dcd941"><td class="memItemLeft" align="right" valign="top"><a id="a5c0a7e723c0e4e0225f3cabbc0dcd941"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>MaxBytesInCache</b><code> [get, set]</code></td></tr>
<tr class="separator:a5c0a7e723c0e4e0225f3cabbc0dcd941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">Sigma.Core.Data.Datasets.IDataset</a></td></tr>
<tr class="memitem:af8c1a60d3478a2dafb4ebedf382d26f4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#af8c1a60d3478a2dafb4ebedf382d26f4">Name</a><code> [get]</code></td></tr>
<tr class="memdesc:af8c1a60d3478a2dafb4ebedf382d26f4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name and identifier of this dataset. <a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset.html" title="A default implementation of the IDataset interface. Provides caching of entire blocks and reader data...">Dataset</a> names should be globally unique and easily identifiable.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#af8c1a60d3478a2dafb4ebedf382d26f4">More...</a><br /></td></tr>
<tr class="separator:af8c1a60d3478a2dafb4ebedf382d26f4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2834cfa9c66324039efccbecf0db4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a4ef2834cfa9c66324039efccbecf0db4">TargetBlockSizeRecords</a><code> [get]</code></td></tr>
<tr class="memdesc:a4ef2834cfa9c66324039efccbecf0db4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The preferred per block size in records. Note: Not every block must obey this request (e.g. the last black might very well be a different size).  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a4ef2834cfa9c66324039efccbecf0db4">More...</a><br /></td></tr>
<tr class="separator:a4ef2834cfa9c66324039efccbecf0db4 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fadf9aedcf24c2f45b9e73e63ccf97e inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a7fadf9aedcf24c2f45b9e73e63ccf97e">MaxConcurrentActiveBlocks</a><code> [get]</code></td></tr>
<tr class="memdesc:a7fadf9aedcf24c2f45b9e73e63ccf97e inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of concurrently active blocks.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a7fadf9aedcf24c2f45b9e73e63ccf97e">More...</a><br /></td></tr>
<tr class="separator:a7fadf9aedcf24c2f45b9e73e63ccf97e inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41b6b52f00ddbe6d8666d343a4e0531 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ad41b6b52f00ddbe6d8666d343a4e0531">MaxTotalActiveBlockSizeBytes</a><code> [get]</code></td></tr>
<tr class="memdesc:ad41b6b52f00ddbe6d8666d343a4e0531 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum total concurrently active block size in bytes.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ad41b6b52f00ddbe6d8666d343a4e0531">More...</a><br /></td></tr>
<tr class="separator:ad41b6b52f00ddbe6d8666d343a4e0531 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75256c09fd644adeab6e58cd2a230f0 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ab75256c09fd644adeab6e58cd2a230f0">TotalActiveBlockSizeBytes</a><code> [get]</code></td></tr>
<tr class="memdesc:ab75256c09fd644adeab6e58cd2a230f0 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total size of all currently active record blocks in system memory in bytes.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ab75256c09fd644adeab6e58cd2a230f0">More...</a><br /></td></tr>
<tr class="separator:ab75256c09fd644adeab6e58cd2a230f0 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19e86c464cebb60f2bc83c4961beaaa inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ab19e86c464cebb60f2bc83c4961beaaa">MaxBlocksInCache</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ab19e86c464cebb60f2bc83c4961beaaa inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maxmimum number of blocks to keep in the cache (inactive blocks are written to a cache, typically on disk, to be reloaded later).  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ab19e86c464cebb60f2bc83c4961beaaa">More...</a><br /></td></tr>
<tr class="separator:ab19e86c464cebb60f2bc83c4961beaaa inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef69f54df7d1d84d99ebb9d97602f135 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aef69f54df7d1d84d99ebb9d97602f135">MaxBytesInCache</a><code> [get, set]</code></td></tr>
<tr class="memdesc:aef69f54df7d1d84d99ebb9d97602f135 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maxmimum number of bytes to keep in the cache (inactive blocks are written to a cache, typically on disk, to be reloaded later).  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aef69f54df7d1d84d99ebb9d97602f135">More...</a><br /></td></tr>
<tr class="separator:aef69f54df7d1d84d99ebb9d97602f135 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef5942f34f79da6c11ca263caf998d8 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">string []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aeef5942f34f79da6c11ca263caf998d8">SectionNames</a><code> [get]</code></td></tr>
<tr class="memdesc:aeef5942f34f79da6c11ca263caf998d8 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The names for all sections present in this dataset (e.g. "inputs", "targets").  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aeef5942f34f79da6c11ca263caf998d8">More...</a><br /></td></tr>
<tr class="separator:aeef5942f34f79da6c11ca263caf998d8 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae460b7cfe55b278c511956933cd243ee inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">IReadOnlyCollection&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ae460b7cfe55b278c511956933cd243ee">ActiveBlockIndices</a><code> [get]</code></td></tr>
<tr class="memdesc:ae460b7cfe55b278c511956933cd243ee inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of currently active and loaded record block indices.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ae460b7cfe55b278c511956933cd243ee">More...</a><br /></td></tr>
<tr class="separator:ae460b7cfe55b278c511956933cd243ee inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9631159c8c2d65d2fe3efafc599c83 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aeb9631159c8c2d65d2fe3efafc599c83">ActiveIndividualBlockCount</a><code> [get]</code></td></tr>
<tr class="memdesc:aeb9631159c8c2d65d2fe3efafc599c83 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of currently active and loaded record blocks, with different block formats counting as different blocks.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aeb9631159c8c2d65d2fe3efafc599c83">More...</a><br /></td></tr>
<tr class="separator:aeb9631159c8c2d65d2fe3efafc599c83 inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaba4340f92392f7724f90270eda47a inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#abfaba4340f92392f7724f90270eda47a">ActiveBlockRegionCount</a><code> [get]</code></td></tr>
<tr class="memdesc:abfaba4340f92392f7724f90270eda47a inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of currently active and loaded record blocks, with different block formats of the same region counting as one active block index.  <a href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#abfaba4340f92392f7724f90270eda47a">More...</a><br /></td></tr>
<tr class="separator:abfaba4340f92392f7724f90270eda47a inherit properties_interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A dataset slice representing a part of an underlying dataset. Block-wise datasets forward some blocks per block, i.e. some entire blocks per slice instead of some parts of each block (as in <a class="el" href="class_sigma_1_1_core_1_1_data_1_1_datasets_1_1_dataset_recordwise_slice.html" title="A dataset slice representing a part of an underlying dataset. Record-wise datasets forward partial bl...">DatasetRecordwiseSlice</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a36daf5dad56f60e45007b14dc7a052b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36daf5dad56f60e45007b14dc7a052b1">&#9670;&nbsp;</a></span>DatasetBlockwiseSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.DatasetBlockwiseSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a>&#160;</td>
          <td class="paramname"><em>underlyingDataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitBeginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitEndIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitInterval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a block-wise slice dataset of an underlying dataset with a certain split. A block-wise split example: In order to assign a slice of 1 out of 5 blocks to this dataset, the split begin index would be 0, split end index 1 and split interval 5. Or split begin of 1 and end of 2, begin of 2 and end of 3, begin of 3 and end of 4, depending on the order in which this slice should take blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">underlyingDataset</td><td>The underlying dataset to slice.</td></tr>
    <tr><td class="paramname">splitBeginIndex</td><td>The begin split index within the interval (inclusive).</td></tr>
    <tr><td class="paramname">splitEndIndex</td><td>The end split index within the interval (inclusive).</td></tr>
    <tr><td class="paramname">splitInterval</td><td>The split interval.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acb5b9e5acc5aafc12936a829e61be5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5b9e5acc5aafc12936a829e61be5b4">&#9670;&nbsp;</a></span>CanFetchBlocksAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.CanFetchBlocksAfter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether any more blocks can be fetched after a specified block index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index after which to check for more blocks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ac2dee44bb005448443d02e2a1c5703a4">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a32b61f4befcdbc58ffc0a18bcfe821bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b61f4befcdbc58ffc0a18bcfe821bf">&#9670;&nbsp;</a></span>FetchBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IDictionary&lt;string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&gt; Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.FetchBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldWaitUntilAvailable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch named record block with a certain index for a certain computation handler. Load, prepare and convert the requested block to the format required by a certain handler unless it was already fetched and is still active in that format. If the specified block can currently not be loaded due to memory constraints (as specified in MaxConcurrentActiveBlocks and MaxTotalActiveBlockSizeBytes): </p>
<ul>
<li>If shouldWaitUntilAvailable flag is set: the calling thread will wait until the block becomes available, fetch the block and return it.</li>
<li>If shouldWaitUntilAvailable flag is not set: null will be returned. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The index of the record block to request.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler for which the block should be requested (specifies the block format).</td></tr>
    <tr><td class="paramname">shouldWaitUntilAvailable</td><td>Indicate if this method should wait for the specified block to become available or return null if it is not immediately available when called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A block record representing the named blocks at the given block index in the format required by the given handler or null if shouldWaitUntilAvailable is set to false and the specified block is unavailable.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#aaa4f7b33e09f9dba6cd0a00f9a5813c8">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="afdec85300e33c8211c17cabc35d3b567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdec85300e33c8211c17cabc35d3b567">&#9670;&nbsp;</a></span>FetchBlockAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task&lt;IDictionary&lt;string, <a class="el" href="interface_sigma_1_1_core_1_1_math_abstract_1_1_i_n_d_array.html">INDArray</a>&gt; &gt; Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.FetchBlockAsync </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldWaitUntilAvailable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a record block with a certain index for a certain computation handler asynchronously. Load, prepare and convert the requested block to the format required by a certain handler unless it was already fetched and is still active in that format. If the specified block can currently not be loaded due to memory constraints (as specified in MaxConcurrentActiveBlocks and MaxTotalActiveBlockSizeBytes): </p>
<ul>
<li>If shouldWaitUntilAvailable flag is set: the task will asynchronously wait until the block becomes available, fetch the block and return it to the caller.</li>
<li>If shouldWaitUntilAvailable flag is not set: null will be returned immediately. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The index of the record block to request.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler for which the block should be requested (specifies the block format).</td></tr>
    <tr><td class="paramname">shouldWaitUntilAvailable</td><td>Indicate if this method should wait for the specified block to become available or return null if it is not immediately available when called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A block record representing the block at the given block index in the format required by the given handler or null if shouldWaitUntilAvailable is set to false and the specified block is unavailable.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a2f24fb69545cb8fd762fd34b11a8d626">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="aeb864eb51984dc88e66fa6dff997c2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb864eb51984dc88e66fa6dff997c2a1">&#9670;&nbsp;</a></span>FreeBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.FreeBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a record block with a certain index associated with the given handler. If all other references to that block index in other formats are freed, the entire block is unloaded (freed) and set to inactive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index to free of the given handler.</td></tr>
    <tr><td class="paramname">handler</td><td>The computation handler the block was originally requested with.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#afce7b78a69002d79c8d5d0f0263220f0">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="ac349c0480289155d88619b3562a4d7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac349c0480289155d88619b3562a4d7f7">&#9670;&nbsp;</a></span>GetBlockSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.GetBlockSizeBytes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (estimated) size of a block in system memory with a certain index and handler format in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the block with the given index and handler format in bytes.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a0a524d9e10e0467c9dcce45d3df877df">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="ac48e4777532999abded68501cf5c571e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48e4777532999abded68501cf5c571e">&#9670;&nbsp;</a></span>IsBlockActive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.IsBlockActive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a certain block index is currently active and loaded in any format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if the given block index is active and loaded.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#ac98db8758547d98b709ca5e10f943a52">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a4a0f27cf6c5ce149ac8deed62af616bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0f27cf6c5ce149ac8deed62af616bf">&#9670;&nbsp;</a></span>IsBlockActive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.IsBlockActive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_sigma_1_1_core_1_1_handlers_1_1_i_computation_handler.html">IComputationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a certain block index is currently active and loaded in a certain handler format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td>The block index to check.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler of which the format should match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if the given block index is active and loaded in the given handler format.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a49b776b98284e5cdc044ef7c2eef40f2">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a0e1f28f5fef143245e8a7dfa3550a572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1f28f5fef143245e8a7dfa3550a572">&#9670;&nbsp;</a></span>MapToUnderlyingIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.MapToUnderlyingIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map an index relative to this dataset slice to an index relative to the underlying dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockIndex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a84f6d5f57e4f1410a60cd23d419938d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f6d5f57e4f1410a60cd23d419938d4">&#9670;&nbsp;</a></span>SplitBlockwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> [] Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.SplitBlockwise </td>
          <td>(</td>
          <td class="paramtype">params int []&#160;</td>
          <td class="paramname"><em>parts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split this dataset block-wise into certain parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parts</td><td>The parts to split into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dataset slices split according to the given parts.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a7fa8ca31044a20347a2b9de0b8f383dd">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a41796ad5214dfcad90f4236f82b711b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41796ad5214dfcad90f4236f82b711b8">&#9670;&nbsp;</a></span>SplitRecordwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html">IDataset</a> [] Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.SplitRecordwise </td>
          <td>(</td>
          <td class="paramtype">params double []&#160;</td>
          <td class="paramname"><em>percentages</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the dataset record-wise into certain parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">percentages</td><td>The percentages to split into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dataset slices split according to the given percentages (0.0 - x - 1.0).</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a303b0af83085c477e5e3c8cc7b357ec5">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<a id="a7e61b88a80aa9ecbe9e4ba7c57b8ee6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e61b88a80aa9ecbe9e4ba7c57b8ee6a">&#9670;&nbsp;</a></span>TrySetBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sigma.Core.Data.Datasets.DatasetBlockwiseSlice.TrySetBlockSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSizeRecords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to set the block size to a new block size if compatible with the current set block size (e.g. if was auto set and this is the first request). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockSizeRecords</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating whether the block size could be set to the requested block size.</dd></dl>

<p>Implements <a class="el" href="interface_sigma_1_1_core_1_1_data_1_1_datasets_1_1_i_dataset.html#a96f8fd72f2232c1760b94d703b1c5bbc">Sigma.Core.Data.Datasets.IDataset</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Plainer/Documents/GitHub/Sigma/Sigma.Core/Data/Datasets/DatasetBlockwiseSlice.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
